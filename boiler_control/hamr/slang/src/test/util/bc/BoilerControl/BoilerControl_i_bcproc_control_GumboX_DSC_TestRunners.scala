// #Sireum

package bc.BoilerControl

import org.sireum._
import bc.GumboXUtil.GumboXResult
import bc.RandomLib
import org.sireum.Random.Gen64
import org.sireum.Random.Impl.Xoshiro256

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

// Distribute SlangCheck test runners

@record class BoilerControl_i_bcproc_control_GumboX_DSC_TestRunner
  extends Random.Gen.TestRunner[BoilerControl_i_bcproc_control_PreState_Container_P]
  with BoilerControl_i_bcproc_control_GumboX_TestHarness {

  val verbose: B = F

  var seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)
  val ranLibboilerReady: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibboilerWaiting: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLiblevelFailAck: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLiblevelRepair: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlFailAck0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlFailAck1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlFailAck2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlFailAck3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlReady0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlReady1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlReady2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlReady3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlRepair0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlRepair1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlRepair2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlRepair3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFailAck0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFailAck1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFailAck2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFailAck3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpRepair0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpRepair1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpRepair2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpRepair3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibsteamFailAck: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibsteamMeterReady: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibsteamRepair: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibstop: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibwaterMeterReady: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFlow0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFlow1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFlow2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFlow3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpOpen0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpOpen1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpOpen2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpOpen3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibsteamRate: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibwaterLevel: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))

  override def next(): BoilerControl_i_bcproc_control_PreState_Container_P = {
    val api_boilerReady = ranLibboilerReady.nextOption_artEmpty()
    val api_boilerWaiting = ranLibboilerWaiting.nextOption_artEmpty()
    val api_levelFailAck = ranLiblevelFailAck.nextOption_artEmpty()
    val api_levelRepair = ranLiblevelRepair.nextOption_artEmpty()
    val api_pumpControlFailAck0 = ranLibpumpControlFailAck0.nextOption_artEmpty()
    val api_pumpControlFailAck1 = ranLibpumpControlFailAck1.nextOption_artEmpty()
    val api_pumpControlFailAck2 = ranLibpumpControlFailAck2.nextOption_artEmpty()
    val api_pumpControlFailAck3 = ranLibpumpControlFailAck3.nextOption_artEmpty()
    val api_pumpControlReady0 = ranLibpumpControlReady0.nextOption_artEmpty()
    val api_pumpControlReady1 = ranLibpumpControlReady1.nextOption_artEmpty()
    val api_pumpControlReady2 = ranLibpumpControlReady2.nextOption_artEmpty()
    val api_pumpControlReady3 = ranLibpumpControlReady3.nextOption_artEmpty()
    val api_pumpControlRepair0 = ranLibpumpControlRepair0.nextOption_artEmpty()
    val api_pumpControlRepair1 = ranLibpumpControlRepair1.nextOption_artEmpty()
    val api_pumpControlRepair2 = ranLibpumpControlRepair2.nextOption_artEmpty()
    val api_pumpControlRepair3 = ranLibpumpControlRepair3.nextOption_artEmpty()
    val api_pumpFailAck0 = ranLibpumpFailAck0.nextOption_artEmpty()
    val api_pumpFailAck1 = ranLibpumpFailAck1.nextOption_artEmpty()
    val api_pumpFailAck2 = ranLibpumpFailAck2.nextOption_artEmpty()
    val api_pumpFailAck3 = ranLibpumpFailAck3.nextOption_artEmpty()
    val api_pumpRepair0 = ranLibpumpRepair0.nextOption_artEmpty()
    val api_pumpRepair1 = ranLibpumpRepair1.nextOption_artEmpty()
    val api_pumpRepair2 = ranLibpumpRepair2.nextOption_artEmpty()
    val api_pumpRepair3 = ranLibpumpRepair3.nextOption_artEmpty()
    val api_steamFailAck = ranLibsteamFailAck.nextOption_artEmpty()
    val api_steamMeterReady = ranLibsteamMeterReady.nextOption_artEmpty()
    val api_steamRepair = ranLibsteamRepair.nextOption_artEmpty()
    val api_stop = ranLibstop.nextOption_artEmpty()
    val api_waterMeterReady = ranLibwaterMeterReady.nextOption_artEmpty()
    val api_pumpFlow0 = ranLibpumpFlow0.nextOptionB()
    val api_pumpFlow1 = ranLibpumpFlow1.nextOptionB()
    val api_pumpFlow2 = ranLibpumpFlow2.nextOptionB()
    val api_pumpFlow3 = ranLibpumpFlow3.nextOptionB()
    val api_pumpOpen0 = ranLibpumpOpen0.nextOptionB()
    val api_pumpOpen1 = ranLibpumpOpen1.nextOptionB()
    val api_pumpOpen2 = ranLibpumpOpen2.nextOptionB()
    val api_pumpOpen3 = ranLibpumpOpen3.nextOptionB()
    val api_steamRate = ranLibsteamRate.nextOptionF32()
    val api_waterLevel = ranLibwaterLevel.nextOptionF32()
    return BoilerControl_i_bcproc_control_PreState_Container_P(
      api_boilerReady, api_boilerWaiting, api_levelFailAck, api_levelRepair, api_pumpControlFailAck0, api_pumpControlFailAck1, api_pumpControlFailAck2, api_pumpControlFailAck3, api_pumpControlReady0, api_pumpControlReady1, api_pumpControlReady2, api_pumpControlReady3, api_pumpControlRepair0, api_pumpControlRepair1, api_pumpControlRepair2, api_pumpControlRepair3, api_pumpFailAck0, api_pumpFailAck1, api_pumpFailAck2, api_pumpFailAck3, api_pumpRepair0, api_pumpRepair1, api_pumpRepair2, api_pumpRepair3, api_steamFailAck, api_steamMeterReady, api_steamRepair, api_stop, api_waterMeterReady, api_pumpFlow0, api_pumpFlow1, api_pumpFlow2, api_pumpFlow3, api_pumpOpen0, api_pumpOpen1, api_pumpOpen2, api_pumpOpen3, api_steamRate, api_waterLevel
    )
  }

  override def toCompactJson(o: BoilerControl_i_bcproc_control_PreState_Container_P): String = {
    return bc.JSON.fromBoilerControlBoilerControl_i_bcproc_control_PreState_Container_P(o, T)
  }

  override def fromJson(json: String): BoilerControl_i_bcproc_control_PreState_Container_P = {
    bc.JSON.toBoilerControlBoilerControl_i_bcproc_control_PreState_Container_P(json) match {
      case Either.Left(o) => return o
      case Either.Right(msg) => halt(msg.string)
    }
  }

  override def test(o: BoilerControl_i_bcproc_control_PreState_Container_P): B = {
    BeforeEntrypoint()
    val r: B = testComputeCBV(o) match {
      case GumboXResult.Pre_Condition_Unsat =>
        bc.DSC_RecordUnsatPre.report(bc.JSON.fromBoilerControlBoilerControl_i_bcproc_control_PreState_Container_P(o, T))
        T
      case GumboXResult.Post_Condition_Fail => F
      case GumboXResult.Post_Condition_Pass => T
    }
    AfterEntrypoint()
    return r
  }
}

@record class BoilerControl_i_bcproc_control_GumboX_DSC_TestRunnerwL
  extends Random.Gen.TestRunner[BoilerControl_i_bcproc_control_PreState_Container_PS]
  with BoilerControl_i_bcproc_control_GumboX_TestHarness {

  val verbose: B = F

  var seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)
  val ranLibC: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibM1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibM2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibN1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibN2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibP: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibU1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibU2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibW: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibhasBoilerSentWaiting: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibisPump0Failing: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibisPump1Failing: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibisPump2Failing: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibisPump3Failing: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibisSteamMeterFailing: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibisWaterMeterFailing: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibmode: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibp0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibp1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibp2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibp3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibq: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibqa1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibqa2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibqc1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibqc2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibshouldUpdatePumps: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibtransmissionFailure: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibv_steamRate: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibboilerReady: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibboilerWaiting: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLiblevelFailAck: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLiblevelRepair: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlFailAck0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlFailAck1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlFailAck2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlFailAck3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlReady0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlReady1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlReady2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlReady3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlRepair0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlRepair1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlRepair2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpControlRepair3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFailAck0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFailAck1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFailAck2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFailAck3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpRepair0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpRepair1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpRepair2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpRepair3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibsteamFailAck: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibsteamMeterReady: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibsteamRepair: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibstop: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibwaterMeterReady: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFlow0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFlow1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFlow2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpFlow3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpOpen0: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpOpen1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpOpen2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibpumpOpen3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibsteamRate: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
  val ranLibwaterLevel: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))

  override def next(): BoilerControl_i_bcproc_control_PreState_Container_PS = {
    val In_C = ranLibC.nextF32()
    val In_M1 = ranLibM1.nextF32()
    val In_M2 = ranLibM2.nextF32()
    val In_N1 = ranLibN1.nextF32()
    val In_N2 = ranLibN2.nextF32()
    val In_P = ranLibP.nextF32()
    val In_U1 = ranLibU1.nextF32()
    val In_U2 = ranLibU2.nextF32()
    val In_W = ranLibW.nextF32()
    val In_hasBoilerSentWaiting = ranLibhasBoilerSentWaiting.nextB()
    val In_isPump0Failing = ranLibisPump0Failing.nextB()
    val In_isPump1Failing = ranLibisPump1Failing.nextB()
    val In_isPump2Failing = ranLibisPump2Failing.nextB()
    val In_isPump3Failing = ranLibisPump3Failing.nextB()
    val In_isSteamMeterFailing = ranLibisSteamMeterFailing.nextB()
    val In_isWaterMeterFailing = ranLibisWaterMeterFailing.nextB()
    val In_mode = ranLibmode.nextBoilerControlOpModeType()
    val In_p0 = ranLibp0.nextF32()
    val In_p1 = ranLibp1.nextF32()
    val In_p2 = ranLibp2.nextF32()
    val In_p3 = ranLibp3.nextF32()
    val In_q = ranLibq.nextF32()
    val In_qa1 = ranLibqa1.nextF32()
    val In_qa2 = ranLibqa2.nextF32()
    val In_qc1 = ranLibqc1.nextF32()
    val In_qc2 = ranLibqc2.nextF32()
    val In_shouldUpdatePumps = ranLibshouldUpdatePumps.nextB()
    val In_transmissionFailure = ranLibtransmissionFailure.nextB()
    val In_v_steamRate = ranLibv_steamRate.nextF32()
    val api_boilerReady = ranLibboilerReady.nextOption_artEmpty()
    val api_boilerWaiting = ranLibboilerWaiting.nextOption_artEmpty()
    val api_levelFailAck = ranLiblevelFailAck.nextOption_artEmpty()
    val api_levelRepair = ranLiblevelRepair.nextOption_artEmpty()
    val api_pumpControlFailAck0 = ranLibpumpControlFailAck0.nextOption_artEmpty()
    val api_pumpControlFailAck1 = ranLibpumpControlFailAck1.nextOption_artEmpty()
    val api_pumpControlFailAck2 = ranLibpumpControlFailAck2.nextOption_artEmpty()
    val api_pumpControlFailAck3 = ranLibpumpControlFailAck3.nextOption_artEmpty()
    val api_pumpControlReady0 = ranLibpumpControlReady0.nextOption_artEmpty()
    val api_pumpControlReady1 = ranLibpumpControlReady1.nextOption_artEmpty()
    val api_pumpControlReady2 = ranLibpumpControlReady2.nextOption_artEmpty()
    val api_pumpControlReady3 = ranLibpumpControlReady3.nextOption_artEmpty()
    val api_pumpControlRepair0 = ranLibpumpControlRepair0.nextOption_artEmpty()
    val api_pumpControlRepair1 = ranLibpumpControlRepair1.nextOption_artEmpty()
    val api_pumpControlRepair2 = ranLibpumpControlRepair2.nextOption_artEmpty()
    val api_pumpControlRepair3 = ranLibpumpControlRepair3.nextOption_artEmpty()
    val api_pumpFailAck0 = ranLibpumpFailAck0.nextOption_artEmpty()
    val api_pumpFailAck1 = ranLibpumpFailAck1.nextOption_artEmpty()
    val api_pumpFailAck2 = ranLibpumpFailAck2.nextOption_artEmpty()
    val api_pumpFailAck3 = ranLibpumpFailAck3.nextOption_artEmpty()
    val api_pumpRepair0 = ranLibpumpRepair0.nextOption_artEmpty()
    val api_pumpRepair1 = ranLibpumpRepair1.nextOption_artEmpty()
    val api_pumpRepair2 = ranLibpumpRepair2.nextOption_artEmpty()
    val api_pumpRepair3 = ranLibpumpRepair3.nextOption_artEmpty()
    val api_steamFailAck = ranLibsteamFailAck.nextOption_artEmpty()
    val api_steamMeterReady = ranLibsteamMeterReady.nextOption_artEmpty()
    val api_steamRepair = ranLibsteamRepair.nextOption_artEmpty()
    val api_stop = ranLibstop.nextOption_artEmpty()
    val api_waterMeterReady = ranLibwaterMeterReady.nextOption_artEmpty()
    val api_pumpFlow0 = ranLibpumpFlow0.nextOptionB()
    val api_pumpFlow1 = ranLibpumpFlow1.nextOptionB()
    val api_pumpFlow2 = ranLibpumpFlow2.nextOptionB()
    val api_pumpFlow3 = ranLibpumpFlow3.nextOptionB()
    val api_pumpOpen0 = ranLibpumpOpen0.nextOptionB()
    val api_pumpOpen1 = ranLibpumpOpen1.nextOptionB()
    val api_pumpOpen2 = ranLibpumpOpen2.nextOptionB()
    val api_pumpOpen3 = ranLibpumpOpen3.nextOptionB()
    val api_steamRate = ranLibsteamRate.nextOptionF32()
    val api_waterLevel = ranLibwaterLevel.nextOptionF32()
    return BoilerControl_i_bcproc_control_PreState_Container_PS(
      In_C, In_M1, In_M2, In_N1, In_N2, In_P, In_U1, In_U2, In_W, In_hasBoilerSentWaiting, In_isPump0Failing, In_isPump1Failing, In_isPump2Failing, In_isPump3Failing, In_isSteamMeterFailing, In_isWaterMeterFailing, In_mode, In_p0, In_p1, In_p2, In_p3, In_q, In_qa1, In_qa2, In_qc1, In_qc2, In_shouldUpdatePumps, In_transmissionFailure, In_v_steamRate, api_boilerReady, api_boilerWaiting, api_levelFailAck, api_levelRepair, api_pumpControlFailAck0, api_pumpControlFailAck1, api_pumpControlFailAck2, api_pumpControlFailAck3, api_pumpControlReady0, api_pumpControlReady1, api_pumpControlReady2, api_pumpControlReady3, api_pumpControlRepair0, api_pumpControlRepair1, api_pumpControlRepair2, api_pumpControlRepair3, api_pumpFailAck0, api_pumpFailAck1, api_pumpFailAck2, api_pumpFailAck3, api_pumpRepair0, api_pumpRepair1, api_pumpRepair2, api_pumpRepair3, api_steamFailAck, api_steamMeterReady, api_steamRepair, api_stop, api_waterMeterReady, api_pumpFlow0, api_pumpFlow1, api_pumpFlow2, api_pumpFlow3, api_pumpOpen0, api_pumpOpen1, api_pumpOpen2, api_pumpOpen3, api_steamRate, api_waterLevel
    )
  }

  override def toCompactJson(o: BoilerControl_i_bcproc_control_PreState_Container_PS): String = {
    return bc.JSON.fromBoilerControlBoilerControl_i_bcproc_control_PreState_Container_PS(o, T)
  }

  override def fromJson(json: String): BoilerControl_i_bcproc_control_PreState_Container_PS = {
    bc.JSON.toBoilerControlBoilerControl_i_bcproc_control_PreState_Container_PS(json) match {
      case Either.Left(o) => return o
      case Either.Right(msg) => halt(msg.string)
    }
  }

  override def test(o: BoilerControl_i_bcproc_control_PreState_Container_PS): B = {
    BeforeEntrypoint()
    val r: B = testComputeCBwLV(o) match {
      case GumboXResult.Pre_Condition_Unsat =>
        bc.DSC_RecordUnsatPre.report(bc.JSON.fromBoilerControlBoilerControl_i_bcproc_control_PreState_Container_PS(o, T))
        T
      case GumboXResult.Post_Condition_Fail => F
      case GumboXResult.Post_Condition_Pass => T
    }
    AfterEntrypoint()
    return r
  }
}
