package bc.BoilerControl

import org.sireum._
import bc.BoilerControl._
import bc.GumboXUtil
import bc.GumboXUtil.GumboXResult
import bc.RandomLib
import org.sireum.Random.Gen64
import org.sireum.Random.Impl.Xoshiro256
import org.scalatest.BeforeAndAfterAll

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object BoilerControl_i_bcproc_control_GumboX_TestHarness_ScalaTest_Generator {

  // CB entrypoint id ~> (testName ~> (retry num ~> preStateContainer)))
  var report: HashSMap[String, HashSMap[String, Map[Z, Option[String]]]] = _

  def resetReport(): Unit = report = HashSMap.empty

  def updateReport(entryPoint: String, result: String, testName: String, retry: Z, jsonContainer: Option[String]): Unit = {
    val key = s"$entryPoint : $result"
    val cbEntries: HashSMap[String, Map[Z, Option[String]]] =
      if (report.contains(key)) report.get(key).get
      else HashSMap.empty
    val testNameEntries: Map[Z, Option[String]] =
      if (cbEntries.contains(testName)) cbEntries.get(testName).get
      else Map.empty
    assert (!testNameEntries.contains(retry))

    report = report + key ~> (cbEntries + (testName ~> (testNameEntries + (retry ~> jsonContainer))))
  }

  def emitReport(): Unit = {
    println("Test Results")
    for(e <- report.entries) {
      println(s"  ${e._1} = ${e._2.size}")
      val attempts = e._2.values.elements.foldLeft(z"0")((o, m) => o + m.size)
      println(s"    Total Attempts = $attempts")
    }
  }

  def deserializeReport(p: Os.Path): HashSMap[String, HashSMap[String, Map[Z, Option[String]]]] = {
    halt("Not yet")
  }

  def serializeReport(dir: Os.Path): Unit = {
    val filename = dir / s"BoilerControl_i_bcproc_control_GumboX_TestHarness_ScalaTest_Generator_${System.currentTimeMillis()}.json"
    //filename.write(JSON.from_artDataContent(GumboXUtil.Report(report), T))
    var map1: HashSMap[String, String] = HashSMap.empty
    for(e <- report.entries) {
      var map2: HashSMap[String, String] = HashSMap.empty
      for (t <- e._2.entries) {
        var map3: Map[Z, String] = Map.empty
        for (r <- t._2.entries) {
          val s: String =
            if (r._2.isEmpty) ""
            else r._2.get
          map3 = map3 + (r._1 ~> s)
        }
        map2 = map2 + (t._1 ~>
          org.sireum.Json.Printer.printMap(T, map3, org.sireum.Json.Printer.printZ _, org.sireum.Json.Printer.printString _).render)
      }
      map1 = map1 + (e._1 ~>
        org.sireum.Json.Printer.printHashSMap(T, map2, org.sireum.Json.Printer.printString _, org.sireum.Json.Printer.printString _).render)
    }
    val sreport = org.sireum.Json.Printer.printHashSMap(T, map1, org.sireum.Json.Printer.printString _, org.sireum.Json.Printer.printString _).render
    filename.write(sreport)
    println(s"Wrote: ${filename.toUri}")
  }
}

import BoilerControl_i_bcproc_control_GumboX_TestHarness_ScalaTest_Generator._

trait BoilerControl_i_bcproc_control_GumboX_TestHarness_ScalaTest_Generator extends BoilerControl_i_bcproc_control_GumboX_TestHarness_ScalaTest
  with BeforeAndAfterAll {

  // return a directory path if you want to serialize the report
  def serializeReportPath: Option[Os.Path] = None()

  def failOnUnsatPreconditions: B = F

  def seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)

  def freshRandomLib: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))

  def getInitialiseProfiles: MSZ[BoilerControl_i_bcproc_control_Profile]

  def getDefaultInitialiseProfile: BoilerControl_i_bcproc_control_Profile = {
    return BoilerControl_i_bcproc_control_Profile (
      name = "Default Initialise Profile",
      numTests = 100)
  }

  def getProfiles_P: MSZ[BoilerControl_i_bcproc_control_Profile_P]

  def getDefaultProfile_P: BoilerControl_i_bcproc_control_Profile_P = {
    return BoilerControl_i_bcproc_control_Profile_P (
      name = "Default Port Profile", 
      numTests = 100, 
      numTestVectorGenRetries = 100, 
      api_boilerReady = freshRandomLib, 
      api_boilerWaiting = freshRandomLib, 
      api_levelFailAck = freshRandomLib, 
      api_levelRepair = freshRandomLib, 
      api_pumpControlFailAck0 = freshRandomLib, 
      api_pumpControlFailAck1 = freshRandomLib, 
      api_pumpControlFailAck2 = freshRandomLib, 
      api_pumpControlFailAck3 = freshRandomLib, 
      api_pumpControlReady0 = freshRandomLib, 
      api_pumpControlReady1 = freshRandomLib, 
      api_pumpControlReady2 = freshRandomLib, 
      api_pumpControlReady3 = freshRandomLib, 
      api_pumpControlRepair0 = freshRandomLib, 
      api_pumpControlRepair1 = freshRandomLib, 
      api_pumpControlRepair2 = freshRandomLib, 
      api_pumpControlRepair3 = freshRandomLib, 
      api_pumpFailAck0 = freshRandomLib, 
      api_pumpFailAck1 = freshRandomLib, 
      api_pumpFailAck2 = freshRandomLib, 
      api_pumpFailAck3 = freshRandomLib, 
      api_pumpRepair0 = freshRandomLib, 
      api_pumpRepair1 = freshRandomLib, 
      api_pumpRepair2 = freshRandomLib, 
      api_pumpRepair3 = freshRandomLib, 
      api_steamFailAck = freshRandomLib, 
      api_steamMeterReady = freshRandomLib, 
      api_steamRepair = freshRandomLib, 
      api_stop = freshRandomLib, 
      api_waterMeterReady = freshRandomLib, 
      api_pumpFlow0 = freshRandomLib, 
      api_pumpFlow1 = freshRandomLib, 
      api_pumpFlow2 = freshRandomLib, 
      api_pumpFlow3 = freshRandomLib, 
      api_pumpOpen0 = freshRandomLib, 
      api_pumpOpen1 = freshRandomLib, 
      api_pumpOpen2 = freshRandomLib, 
      api_pumpOpen3 = freshRandomLib, 
      api_steamRate = freshRandomLib, 
      api_waterLevel = freshRandomLib)
  }

  def getProfiles_PS: MSZ[BoilerControl_i_bcproc_control_Profile_PS]

  def getDefaultProfile_PS: BoilerControl_i_bcproc_control_Profile_PS = {
    return BoilerControl_i_bcproc_control_Profile_PS (
      name = "Default Port and State Variable Profile", 
      numTests = 100, 
      numTestVectorGenRetries = 100, 
      In_C = freshRandomLib, 
      In_M1 = freshRandomLib, 
      In_M2 = freshRandomLib, 
      In_N1 = freshRandomLib, 
      In_N2 = freshRandomLib, 
      In_P = freshRandomLib, 
      In_U1 = freshRandomLib, 
      In_U2 = freshRandomLib, 
      In_W = freshRandomLib, 
      In_hasBoilerSentWaiting = freshRandomLib, 
      In_isPump0Failing = freshRandomLib, 
      In_isPump1Failing = freshRandomLib, 
      In_isPump2Failing = freshRandomLib, 
      In_isPump3Failing = freshRandomLib, 
      In_isSteamMeterFailing = freshRandomLib, 
      In_isWaterMeterFailing = freshRandomLib, 
      In_mode = freshRandomLib, 
      In_p0 = freshRandomLib, 
      In_p1 = freshRandomLib, 
      In_p2 = freshRandomLib, 
      In_p3 = freshRandomLib, 
      In_q = freshRandomLib, 
      In_qa1 = freshRandomLib, 
      In_qa2 = freshRandomLib, 
      In_qc1 = freshRandomLib, 
      In_qc2 = freshRandomLib, 
      In_shouldUpdatePumps = freshRandomLib, 
      In_transmissionFailure = freshRandomLib, 
      In_v_steamRate = freshRandomLib, 
      api_boilerReady = freshRandomLib, 
      api_boilerWaiting = freshRandomLib, 
      api_levelFailAck = freshRandomLib, 
      api_levelRepair = freshRandomLib, 
      api_pumpControlFailAck0 = freshRandomLib, 
      api_pumpControlFailAck1 = freshRandomLib, 
      api_pumpControlFailAck2 = freshRandomLib, 
      api_pumpControlFailAck3 = freshRandomLib, 
      api_pumpControlReady0 = freshRandomLib, 
      api_pumpControlReady1 = freshRandomLib, 
      api_pumpControlReady2 = freshRandomLib, 
      api_pumpControlReady3 = freshRandomLib, 
      api_pumpControlRepair0 = freshRandomLib, 
      api_pumpControlRepair1 = freshRandomLib, 
      api_pumpControlRepair2 = freshRandomLib, 
      api_pumpControlRepair3 = freshRandomLib, 
      api_pumpFailAck0 = freshRandomLib, 
      api_pumpFailAck1 = freshRandomLib, 
      api_pumpFailAck2 = freshRandomLib, 
      api_pumpFailAck3 = freshRandomLib, 
      api_pumpRepair0 = freshRandomLib, 
      api_pumpRepair1 = freshRandomLib, 
      api_pumpRepair2 = freshRandomLib, 
      api_pumpRepair3 = freshRandomLib, 
      api_steamFailAck = freshRandomLib, 
      api_steamMeterReady = freshRandomLib, 
      api_steamRepair = freshRandomLib, 
      api_stop = freshRandomLib, 
      api_waterMeterReady = freshRandomLib, 
      api_pumpFlow0 = freshRandomLib, 
      api_pumpFlow1 = freshRandomLib, 
      api_pumpFlow2 = freshRandomLib, 
      api_pumpFlow3 = freshRandomLib, 
      api_pumpOpen0 = freshRandomLib, 
      api_pumpOpen1 = freshRandomLib, 
      api_pumpOpen2 = freshRandomLib, 
      api_pumpOpen3 = freshRandomLib, 
      api_steamRate = freshRandomLib, 
      api_waterLevel = freshRandomLib)
  }

  def next(profile: BoilerControl_i_bcproc_control_Profile_P): Option[BoilerControl_i_bcproc_control_PreState_Container_P] = {
    try {
      val api_boilerReady = profile.api_boilerReady.nextOption_artEmpty()
      val api_boilerWaiting = profile.api_boilerWaiting.nextOption_artEmpty()
      val api_levelFailAck = profile.api_levelFailAck.nextOption_artEmpty()
      val api_levelRepair = profile.api_levelRepair.nextOption_artEmpty()
      val api_pumpControlFailAck0 = profile.api_pumpControlFailAck0.nextOption_artEmpty()
      val api_pumpControlFailAck1 = profile.api_pumpControlFailAck1.nextOption_artEmpty()
      val api_pumpControlFailAck2 = profile.api_pumpControlFailAck2.nextOption_artEmpty()
      val api_pumpControlFailAck3 = profile.api_pumpControlFailAck3.nextOption_artEmpty()
      val api_pumpControlReady0 = profile.api_pumpControlReady0.nextOption_artEmpty()
      val api_pumpControlReady1 = profile.api_pumpControlReady1.nextOption_artEmpty()
      val api_pumpControlReady2 = profile.api_pumpControlReady2.nextOption_artEmpty()
      val api_pumpControlReady3 = profile.api_pumpControlReady3.nextOption_artEmpty()
      val api_pumpControlRepair0 = profile.api_pumpControlRepair0.nextOption_artEmpty()
      val api_pumpControlRepair1 = profile.api_pumpControlRepair1.nextOption_artEmpty()
      val api_pumpControlRepair2 = profile.api_pumpControlRepair2.nextOption_artEmpty()
      val api_pumpControlRepair3 = profile.api_pumpControlRepair3.nextOption_artEmpty()
      val api_pumpFailAck0 = profile.api_pumpFailAck0.nextOption_artEmpty()
      val api_pumpFailAck1 = profile.api_pumpFailAck1.nextOption_artEmpty()
      val api_pumpFailAck2 = profile.api_pumpFailAck2.nextOption_artEmpty()
      val api_pumpFailAck3 = profile.api_pumpFailAck3.nextOption_artEmpty()
      val api_pumpRepair0 = profile.api_pumpRepair0.nextOption_artEmpty()
      val api_pumpRepair1 = profile.api_pumpRepair1.nextOption_artEmpty()
      val api_pumpRepair2 = profile.api_pumpRepair2.nextOption_artEmpty()
      val api_pumpRepair3 = profile.api_pumpRepair3.nextOption_artEmpty()
      val api_steamFailAck = profile.api_steamFailAck.nextOption_artEmpty()
      val api_steamMeterReady = profile.api_steamMeterReady.nextOption_artEmpty()
      val api_steamRepair = profile.api_steamRepair.nextOption_artEmpty()
      val api_stop = profile.api_stop.nextOption_artEmpty()
      val api_waterMeterReady = profile.api_waterMeterReady.nextOption_artEmpty()
      val api_pumpFlow0 = profile.api_pumpFlow0.nextOptionB()
      val api_pumpFlow1 = profile.api_pumpFlow1.nextOptionB()
      val api_pumpFlow2 = profile.api_pumpFlow2.nextOptionB()
      val api_pumpFlow3 = profile.api_pumpFlow3.nextOptionB()
      val api_pumpOpen0 = profile.api_pumpOpen0.nextOptionB()
      val api_pumpOpen1 = profile.api_pumpOpen1.nextOptionB()
      val api_pumpOpen2 = profile.api_pumpOpen2.nextOptionB()
      val api_pumpOpen3 = profile.api_pumpOpen3.nextOptionB()
      val api_steamRate = profile.api_steamRate.nextOptionF32()
      val api_waterLevel = profile.api_waterLevel.nextOptionF32()

      return Some(BoilerControl_i_bcproc_control_PreState_Container_P(api_boilerReady,api_boilerWaiting,api_levelFailAck,api_levelRepair,api_pumpControlFailAck0,api_pumpControlFailAck1,api_pumpControlFailAck2,api_pumpControlFailAck3,api_pumpControlReady0,api_pumpControlReady1,api_pumpControlReady2,api_pumpControlReady3,api_pumpControlRepair0,api_pumpControlRepair1,api_pumpControlRepair2,api_pumpControlRepair3,api_pumpFailAck0,api_pumpFailAck1,api_pumpFailAck2,api_pumpFailAck3,api_pumpRepair0,api_pumpRepair1,api_pumpRepair2,api_pumpRepair3,api_steamFailAck,api_steamMeterReady,api_steamRepair,api_stop,api_waterMeterReady,api_pumpFlow0,api_pumpFlow1,api_pumpFlow2,api_pumpFlow3,api_pumpOpen0,api_pumpOpen1,api_pumpOpen2,api_pumpOpen3,api_steamRate,api_waterLevel))
    } catch {
      case e: AssertionError =>
       // SlangCheck was unable to satisfy a datatype's filter
       return None()
    }
  }

  def nextwL(profile: BoilerControl_i_bcproc_control_Profile_PS): Option[BoilerControl_i_bcproc_control_PreState_Container_PS] = {
    try {
      val In_C = profile.In_C.nextF32()
      val In_M1 = profile.In_M1.nextF32()
      val In_M2 = profile.In_M2.nextF32()
      val In_N1 = profile.In_N1.nextF32()
      val In_N2 = profile.In_N2.nextF32()
      val In_P = profile.In_P.nextF32()
      val In_U1 = profile.In_U1.nextF32()
      val In_U2 = profile.In_U2.nextF32()
      val In_W = profile.In_W.nextF32()
      val In_hasBoilerSentWaiting = profile.In_hasBoilerSentWaiting.nextB()
      val In_isPump0Failing = profile.In_isPump0Failing.nextB()
      val In_isPump1Failing = profile.In_isPump1Failing.nextB()
      val In_isPump2Failing = profile.In_isPump2Failing.nextB()
      val In_isPump3Failing = profile.In_isPump3Failing.nextB()
      val In_isSteamMeterFailing = profile.In_isSteamMeterFailing.nextB()
      val In_isWaterMeterFailing = profile.In_isWaterMeterFailing.nextB()
      val In_mode = profile.In_mode.nextBoilerControlOpModeType()
      val In_p0 = profile.In_p0.nextF32()
      val In_p1 = profile.In_p1.nextF32()
      val In_p2 = profile.In_p2.nextF32()
      val In_p3 = profile.In_p3.nextF32()
      val In_q = profile.In_q.nextF32()
      val In_qa1 = profile.In_qa1.nextF32()
      val In_qa2 = profile.In_qa2.nextF32()
      val In_qc1 = profile.In_qc1.nextF32()
      val In_qc2 = profile.In_qc2.nextF32()
      val In_shouldUpdatePumps = profile.In_shouldUpdatePumps.nextB()
      val In_transmissionFailure = profile.In_transmissionFailure.nextB()
      val In_v_steamRate = profile.In_v_steamRate.nextF32()
      val api_boilerReady = profile.api_boilerReady.nextOption_artEmpty()
      val api_boilerWaiting = profile.api_boilerWaiting.nextOption_artEmpty()
      val api_levelFailAck = profile.api_levelFailAck.nextOption_artEmpty()
      val api_levelRepair = profile.api_levelRepair.nextOption_artEmpty()
      val api_pumpControlFailAck0 = profile.api_pumpControlFailAck0.nextOption_artEmpty()
      val api_pumpControlFailAck1 = profile.api_pumpControlFailAck1.nextOption_artEmpty()
      val api_pumpControlFailAck2 = profile.api_pumpControlFailAck2.nextOption_artEmpty()
      val api_pumpControlFailAck3 = profile.api_pumpControlFailAck3.nextOption_artEmpty()
      val api_pumpControlReady0 = profile.api_pumpControlReady0.nextOption_artEmpty()
      val api_pumpControlReady1 = profile.api_pumpControlReady1.nextOption_artEmpty()
      val api_pumpControlReady2 = profile.api_pumpControlReady2.nextOption_artEmpty()
      val api_pumpControlReady3 = profile.api_pumpControlReady3.nextOption_artEmpty()
      val api_pumpControlRepair0 = profile.api_pumpControlRepair0.nextOption_artEmpty()
      val api_pumpControlRepair1 = profile.api_pumpControlRepair1.nextOption_artEmpty()
      val api_pumpControlRepair2 = profile.api_pumpControlRepair2.nextOption_artEmpty()
      val api_pumpControlRepair3 = profile.api_pumpControlRepair3.nextOption_artEmpty()
      val api_pumpFailAck0 = profile.api_pumpFailAck0.nextOption_artEmpty()
      val api_pumpFailAck1 = profile.api_pumpFailAck1.nextOption_artEmpty()
      val api_pumpFailAck2 = profile.api_pumpFailAck2.nextOption_artEmpty()
      val api_pumpFailAck3 = profile.api_pumpFailAck3.nextOption_artEmpty()
      val api_pumpRepair0 = profile.api_pumpRepair0.nextOption_artEmpty()
      val api_pumpRepair1 = profile.api_pumpRepair1.nextOption_artEmpty()
      val api_pumpRepair2 = profile.api_pumpRepair2.nextOption_artEmpty()
      val api_pumpRepair3 = profile.api_pumpRepair3.nextOption_artEmpty()
      val api_steamFailAck = profile.api_steamFailAck.nextOption_artEmpty()
      val api_steamMeterReady = profile.api_steamMeterReady.nextOption_artEmpty()
      val api_steamRepair = profile.api_steamRepair.nextOption_artEmpty()
      val api_stop = profile.api_stop.nextOption_artEmpty()
      val api_waterMeterReady = profile.api_waterMeterReady.nextOption_artEmpty()
      val api_pumpFlow0 = profile.api_pumpFlow0.nextOptionB()
      val api_pumpFlow1 = profile.api_pumpFlow1.nextOptionB()
      val api_pumpFlow2 = profile.api_pumpFlow2.nextOptionB()
      val api_pumpFlow3 = profile.api_pumpFlow3.nextOptionB()
      val api_pumpOpen0 = profile.api_pumpOpen0.nextOptionB()
      val api_pumpOpen1 = profile.api_pumpOpen1.nextOptionB()
      val api_pumpOpen2 = profile.api_pumpOpen2.nextOptionB()
      val api_pumpOpen3 = profile.api_pumpOpen3.nextOptionB()
      val api_steamRate = profile.api_steamRate.nextOptionF32()
      val api_waterLevel = profile.api_waterLevel.nextOptionF32()

      return Some(BoilerControl_i_bcproc_control_PreState_Container_PS(In_C,In_M1,In_M2,In_N1,In_N2,In_P,In_U1,In_U2,In_W,In_hasBoilerSentWaiting,In_isPump0Failing,In_isPump1Failing,In_isPump2Failing,In_isPump3Failing,In_isSteamMeterFailing,In_isWaterMeterFailing,In_mode,In_p0,In_p1,In_p2,In_p3,In_q,In_qa1,In_qa2,In_qc1,In_qc2,In_shouldUpdatePumps,In_transmissionFailure,In_v_steamRate,api_boilerReady,api_boilerWaiting,api_levelFailAck,api_levelRepair,api_pumpControlFailAck0,api_pumpControlFailAck1,api_pumpControlFailAck2,api_pumpControlFailAck3,api_pumpControlReady0,api_pumpControlReady1,api_pumpControlReady2,api_pumpControlReady3,api_pumpControlRepair0,api_pumpControlRepair1,api_pumpControlRepair2,api_pumpControlRepair3,api_pumpFailAck0,api_pumpFailAck1,api_pumpFailAck2,api_pumpFailAck3,api_pumpRepair0,api_pumpRepair1,api_pumpRepair2,api_pumpRepair3,api_steamFailAck,api_steamMeterReady,api_steamRepair,api_stop,api_waterMeterReady,api_pumpFlow0,api_pumpFlow1,api_pumpFlow2,api_pumpFlow3,api_pumpOpen0,api_pumpOpen1,api_pumpOpen2,api_pumpOpen3,api_steamRate,api_waterLevel))
    } catch {
      case e: AssertionError =>
       // SlangCheck was unable to satisfy a datatype's filter
       return None()
    }
  }

  override def beforeAll(): Unit = resetReport()

  override def afterAll(): Unit = {
    emitReport()
    serializeReportPath match {
      case Some (p) => serializeReport(p)
      case _ =>
    }
  }

  for (profile <- getInitialiseProfiles) {
    testInitialiseCB_Profile(profile)
  }

  def testInitialiseCB_Profile(profile: BoilerControl_i_bcproc_control_Profile): Unit = {
    for (i <- 0 until profile.numTests) {
      val testName = s"Profile \"${profile.name}\": testInitialiseCB_$i"
      this.registerTest(testName) {
        val results = testInitialiseCB()
        updateReport("testInitialiseCB", results.name, testName, 0, None())

        results match {
          case GumboXResult.Pre_Condition_Unsat =>
            halt("Infeasible as initialize entry points cannot contain assume clauses and cannot access incoming ports or state variables")
          case GumboXResult.Post_Condition_Fail =>
            fail ("Post condition did not hold")
          case GumboXResult.Post_Condition_Pass =>
            if (verbose) {
              println ("Success!")
            }
        }
      }
    }
  }

  for (profile <- getProfiles_P) {
    testComputeCB_Profile_P(profile)
  }

  def testComputeCB_Profile_P(profile: BoilerControl_i_bcproc_control_Profile_P): Unit = {
    for (i <- 0 until profile.numTests) {
      val testName = s"Profile \"${profile.name}\": testComputeCB_$i"
      val escapedTestName = s"Profile \\\"${profile.name}\\\": testComputeCB_$i"

      this.registerTest(testName) {
        var retry: B = T

        var j: Z = 0
        while (j < profile.numTestVectorGenRetries && retry) {
          next(profile) match {
            case Some(o) =>

              if (verbose && j > 0) {
                println(s"Retry $j:")
              }

              val results = testComputeCBV(o)

              val json = bc.JSON.fromBoilerControlBoilerControl_i_bcproc_control_PreState_Container_P(o, T)
              updateReport("testComputeCB_Profile_P", results.name, testName, j, Some(json))

              if (verbose) {
                val tq = "\"\"\""
                println(st"""Replay Unit Test:
                            |  test("Replay: $escapedTestName") {
                            |    val json = st${tq}${json}${tq}.render
                            |    val testVector = bc.JSON.toBoilerControlBoilerControl_i_bcproc_control_PreState_Container_P(json).left
                            |    assert (testComputeCBV(testVector) == bc.GumboXUtil.GumboXResult.$results)
                            |  }""".render)
              }

              results match {
                case GumboXResult.Pre_Condition_Unsat =>
                case GumboXResult.Post_Condition_Fail =>
                  fail ("Post condition did not hold")
                  retry = F
                case GumboXResult.Post_Condition_Pass =>
                  if (verbose) {
                    println ("Success!")
                  }
                  retry = F
              }
            case _ =>
              updateReport("testComputeCB_Profile_P", "SlangCheck RTS", testName, j, None())
          }
          j = j + 1
        }

        if (retry) {
          if (failOnUnsatPreconditions) {
            fail ("Unable to satisfy precondition")
          } else if (verbose) {
            cprintln(T, "Unable to satisfy precondition")
          }
        }
      }
    }
  }

  for (profile <- getProfiles_PS) {
    testComputeCBwL_Profile_PS(profile)
  }

  def testComputeCBwL_Profile_PS(profile: BoilerControl_i_bcproc_control_Profile_PS): Unit = {
    for (i <- 0 until profile.numTests) {
      val testName = s"Profile \"${profile.name}\": testComputeCBwL_$i"
      val escapedTestName = s"Profile \\\"${profile.name}\\\": testComputeCBwL_$i"

      this.registerTest(testName) {
        var retry: B = T

        var j: Z = 0
        while (j < profile.numTestVectorGenRetries && retry) {
          nextwL(profile) match {
            case Some(o) =>

              if (verbose && j > 0) {
                println(s"Retry $j:")
              }

              val results = testComputeCBwLV(o)

              val json = bc.JSON.fromBoilerControlBoilerControl_i_bcproc_control_PreState_Container_PS(o, T)
              updateReport("testComputeCBwL_Profile_PS", results.name, testName, j, Some(json))

              if (verbose) {
                val tq = "\"\"\""
                println(st"""Replay Unit Test:
                            |  test("Replay: $escapedTestName") {
                            |    val json = st${tq}${json}${tq}.render
                            |    val testVector = bc.JSON.toBoilerControlBoilerControl_i_bcproc_control_PreState_Container_PS(json).left
                            |    assert (testComputeCBwLV(testVector) == bc.GumboXUtil.GumboXResult.$results)
                            |  }""".render)
              }

              results match {
                case GumboXResult.Pre_Condition_Unsat =>
                case GumboXResult.Post_Condition_Fail =>
                  fail ("Post condition did not hold")
                  retry = F
                case GumboXResult.Post_Condition_Pass =>
                  if (verbose) {
                    println ("Success!")
                  }
                  retry = F
              }
            case _ =>
              updateReport("testComputeCBwL_Profile_PS", "SlangCheck RTS", testName, j, None())
          }
          j = j + 1
        }

        if (retry) {
          if (failOnUnsatPreconditions) {
            fail ("Unable to satisfy precondition")
          } else if (verbose) {
            cprintln(T, "Unable to satisfy precondition")
          }
        }
      }
    }
  }
}