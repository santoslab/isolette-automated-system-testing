// #Sireum

package bc.BoilerControl

import org.sireum._
import art.Art
import bc._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun
@msig trait OperatorDesk_i_bcproc_desk_TestApi {

  def BeforeEntrypoint(): Unit = {
    Art.initTest(Arch.BoilerControlSystem_i_Instance_bcproc_desk)
  }

  def AfterEntrypoint(): Unit = {
    Art.finalizeTest(Arch.BoilerControlSystem_i_Instance_bcproc_desk)
  }

  def testCompute(): Unit = {
    Art.manuallyClearOutput()
    Art.testCompute(Arch.BoilerControlSystem_i_Instance_bcproc_desk)
  }

  def testInitialise(): Unit = {
    Art.manuallyClearOutput()
    Art.testInitialise(Arch.BoilerControlSystem_i_Instance_bcproc_desk)
  }

  /** helper function to set the values of all input ports.
   * @param opMode payloads for event data port opMode.
   *   ART currently supports single element event data queues so
   *   only the last element of opMode will be used
   * @param pumpFail0 the number of events to place in the pumpFail0 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpFail1 the number of events to place in the pumpFail1 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpFail2 the number of events to place in the pumpFail2 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpFail3 the number of events to place in the pumpFail3 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlFail0 the number of events to place in the pumpControlFail0 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlFail1 the number of events to place in the pumpControlFail1 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlFail2 the number of events to place in the pumpControlFail2 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlFail3 the number of events to place in the pumpControlFail3 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param levelFail the number of events to place in the levelFail event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param steamFail the number of events to place in the steamFail event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpRepairAck0 the number of events to place in the pumpRepairAck0 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpRepairAck1 the number of events to place in the pumpRepairAck1 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpRepairAck2 the number of events to place in the pumpRepairAck2 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpRepairAck3 the number of events to place in the pumpRepairAck3 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlRepairAck0 the number of events to place in the pumpControlRepairAck0 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlRepairAck1 the number of events to place in the pumpControlRepairAck1 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlRepairAck2 the number of events to place in the pumpControlRepairAck2 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlRepairAck3 the number of events to place in the pumpControlRepairAck3 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param levelRepairAck the number of events to place in the levelRepairAck event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param steamRepairAck the number of events to place in the steamRepairAck event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   */
  def put_concrete_inputs(opMode : ISZ[BoilerControl.OpMode.Type],
                          pumpFail0 : Z,
                          pumpFail1 : Z,
                          pumpFail2 : Z,
                          pumpFail3 : Z,
                          pumpControlFail0 : Z,
                          pumpControlFail1 : Z,
                          pumpControlFail2 : Z,
                          pumpControlFail3 : Z,
                          levelFail : Z,
                          steamFail : Z,
                          pumpRepairAck0 : Z,
                          pumpRepairAck1 : Z,
                          pumpRepairAck2 : Z,
                          pumpRepairAck3 : Z,
                          pumpControlRepairAck0 : Z,
                          pumpControlRepairAck1 : Z,
                          pumpControlRepairAck2 : Z,
                          pumpControlRepairAck3 : Z,
                          levelRepairAck : Z,
                          steamRepairAck : Z): Unit = {
    for(v <- opMode){
      put_opMode(v)
    }
    for(i <- 0 until pumpFail0) {
      put_pumpFail0()
    }
    for(i <- 0 until pumpFail1) {
      put_pumpFail1()
    }
    for(i <- 0 until pumpFail2) {
      put_pumpFail2()
    }
    for(i <- 0 until pumpFail3) {
      put_pumpFail3()
    }
    for(i <- 0 until pumpControlFail0) {
      put_pumpControlFail0()
    }
    for(i <- 0 until pumpControlFail1) {
      put_pumpControlFail1()
    }
    for(i <- 0 until pumpControlFail2) {
      put_pumpControlFail2()
    }
    for(i <- 0 until pumpControlFail3) {
      put_pumpControlFail3()
    }
    for(i <- 0 until levelFail) {
      put_levelFail()
    }
    for(i <- 0 until steamFail) {
      put_steamFail()
    }
    for(i <- 0 until pumpRepairAck0) {
      put_pumpRepairAck0()
    }
    for(i <- 0 until pumpRepairAck1) {
      put_pumpRepairAck1()
    }
    for(i <- 0 until pumpRepairAck2) {
      put_pumpRepairAck2()
    }
    for(i <- 0 until pumpRepairAck3) {
      put_pumpRepairAck3()
    }
    for(i <- 0 until pumpControlRepairAck0) {
      put_pumpControlRepairAck0()
    }
    for(i <- 0 until pumpControlRepairAck1) {
      put_pumpControlRepairAck1()
    }
    for(i <- 0 until pumpControlRepairAck2) {
      put_pumpControlRepairAck2()
    }
    for(i <- 0 until pumpControlRepairAck3) {
      put_pumpControlRepairAck3()
    }
    for(i <- 0 until levelRepairAck) {
      put_levelRepairAck()
    }
    for(i <- 0 until steamRepairAck) {
      put_steamRepairAck()
    }
  }


  /** helper function to check OperatorDesk_i_bcproc_desk's
   * output ports.  Use named arguments to check subsets of the output ports.
   * @param stop method that will be called with the number of events to be sent
   *        on the outgoing event port 'stop'.
   * @param pumpRepair0 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpRepair0'.
   * @param pumpRepair1 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpRepair1'.
   * @param pumpRepair2 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpRepair2'.
   * @param pumpRepair3 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpRepair3'.
   * @param pumpControlRepair0 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlRepair0'.
   * @param pumpControlRepair1 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlRepair1'.
   * @param pumpControlRepair2 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlRepair2'.
   * @param pumpControlRepair3 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlRepair3'.
   * @param levelRepair method that will be called with the number of events to be sent
   *        on the outgoing event port 'levelRepair'.
   * @param steamRepair method that will be called with the number of events to be sent
   *        on the outgoing event port 'steamRepair'.
   * @param pumpFailAck0 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpFailAck0'.
   * @param pumpFailAck1 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpFailAck1'.
   * @param pumpFailAck2 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpFailAck2'.
   * @param pumpFailAck3 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpFailAck3'.
   * @param pumpControlFailAck0 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlFailAck0'.
   * @param pumpControlFailAck1 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlFailAck1'.
   * @param pumpControlFailAck2 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlFailAck2'.
   * @param pumpControlFailAck3 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlFailAck3'.
   * @param levelFailAck method that will be called with the number of events to be sent
   *        on the outgoing event port 'levelFailAck'.
   * @param steamFailAck method that will be called with the number of events to be sent
   *        on the outgoing event port 'steamFailAck'.
   */
  def check_concrete_output(stop: Z => B,
                            pumpRepair0: Z => B,
                            pumpRepair1: Z => B,
                            pumpRepair2: Z => B,
                            pumpRepair3: Z => B,
                            pumpControlRepair0: Z => B,
                            pumpControlRepair1: Z => B,
                            pumpControlRepair2: Z => B,
                            pumpControlRepair3: Z => B,
                            levelRepair: Z => B,
                            steamRepair: Z => B,
                            pumpFailAck0: Z => B,
                            pumpFailAck1: Z => B,
                            pumpFailAck2: Z => B,
                            pumpFailAck3: Z => B,
                            pumpControlFailAck0: Z => B,
                            pumpControlFailAck1: Z => B,
                            pumpControlFailAck2: Z => B,
                            pumpControlFailAck3: Z => B,
                            levelFailAck: Z => B,
                            steamFailAck: Z => B): Unit = {
    var testFailures: ISZ[ST] = ISZ()

    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val stopValue: Z = if(get_stop().nonEmpty) z"1" else z"0"
    if(!stop(stopValue)) {
      testFailures = testFailures :+ st"'stop' did not match expected: ${stopValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpRepair0Value: Z = if(get_pumpRepair0().nonEmpty) z"1" else z"0"
    if(!pumpRepair0(pumpRepair0Value)) {
      testFailures = testFailures :+ st"'pumpRepair0' did not match expected: ${pumpRepair0Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpRepair1Value: Z = if(get_pumpRepair1().nonEmpty) z"1" else z"0"
    if(!pumpRepair1(pumpRepair1Value)) {
      testFailures = testFailures :+ st"'pumpRepair1' did not match expected: ${pumpRepair1Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpRepair2Value: Z = if(get_pumpRepair2().nonEmpty) z"1" else z"0"
    if(!pumpRepair2(pumpRepair2Value)) {
      testFailures = testFailures :+ st"'pumpRepair2' did not match expected: ${pumpRepair2Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpRepair3Value: Z = if(get_pumpRepair3().nonEmpty) z"1" else z"0"
    if(!pumpRepair3(pumpRepair3Value)) {
      testFailures = testFailures :+ st"'pumpRepair3' did not match expected: ${pumpRepair3Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlRepair0Value: Z = if(get_pumpControlRepair0().nonEmpty) z"1" else z"0"
    if(!pumpControlRepair0(pumpControlRepair0Value)) {
      testFailures = testFailures :+ st"'pumpControlRepair0' did not match expected: ${pumpControlRepair0Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlRepair1Value: Z = if(get_pumpControlRepair1().nonEmpty) z"1" else z"0"
    if(!pumpControlRepair1(pumpControlRepair1Value)) {
      testFailures = testFailures :+ st"'pumpControlRepair1' did not match expected: ${pumpControlRepair1Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlRepair2Value: Z = if(get_pumpControlRepair2().nonEmpty) z"1" else z"0"
    if(!pumpControlRepair2(pumpControlRepair2Value)) {
      testFailures = testFailures :+ st"'pumpControlRepair2' did not match expected: ${pumpControlRepair2Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlRepair3Value: Z = if(get_pumpControlRepair3().nonEmpty) z"1" else z"0"
    if(!pumpControlRepair3(pumpControlRepair3Value)) {
      testFailures = testFailures :+ st"'pumpControlRepair3' did not match expected: ${pumpControlRepair3Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val levelRepairValue: Z = if(get_levelRepair().nonEmpty) z"1" else z"0"
    if(!levelRepair(levelRepairValue)) {
      testFailures = testFailures :+ st"'levelRepair' did not match expected: ${levelRepairValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val steamRepairValue: Z = if(get_steamRepair().nonEmpty) z"1" else z"0"
    if(!steamRepair(steamRepairValue)) {
      testFailures = testFailures :+ st"'steamRepair' did not match expected: ${steamRepairValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpFailAck0Value: Z = if(get_pumpFailAck0().nonEmpty) z"1" else z"0"
    if(!pumpFailAck0(pumpFailAck0Value)) {
      testFailures = testFailures :+ st"'pumpFailAck0' did not match expected: ${pumpFailAck0Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpFailAck1Value: Z = if(get_pumpFailAck1().nonEmpty) z"1" else z"0"
    if(!pumpFailAck1(pumpFailAck1Value)) {
      testFailures = testFailures :+ st"'pumpFailAck1' did not match expected: ${pumpFailAck1Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpFailAck2Value: Z = if(get_pumpFailAck2().nonEmpty) z"1" else z"0"
    if(!pumpFailAck2(pumpFailAck2Value)) {
      testFailures = testFailures :+ st"'pumpFailAck2' did not match expected: ${pumpFailAck2Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpFailAck3Value: Z = if(get_pumpFailAck3().nonEmpty) z"1" else z"0"
    if(!pumpFailAck3(pumpFailAck3Value)) {
      testFailures = testFailures :+ st"'pumpFailAck3' did not match expected: ${pumpFailAck3Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlFailAck0Value: Z = if(get_pumpControlFailAck0().nonEmpty) z"1" else z"0"
    if(!pumpControlFailAck0(pumpControlFailAck0Value)) {
      testFailures = testFailures :+ st"'pumpControlFailAck0' did not match expected: ${pumpControlFailAck0Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlFailAck1Value: Z = if(get_pumpControlFailAck1().nonEmpty) z"1" else z"0"
    if(!pumpControlFailAck1(pumpControlFailAck1Value)) {
      testFailures = testFailures :+ st"'pumpControlFailAck1' did not match expected: ${pumpControlFailAck1Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlFailAck2Value: Z = if(get_pumpControlFailAck2().nonEmpty) z"1" else z"0"
    if(!pumpControlFailAck2(pumpControlFailAck2Value)) {
      testFailures = testFailures :+ st"'pumpControlFailAck2' did not match expected: ${pumpControlFailAck2Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlFailAck3Value: Z = if(get_pumpControlFailAck3().nonEmpty) z"1" else z"0"
    if(!pumpControlFailAck3(pumpControlFailAck3Value)) {
      testFailures = testFailures :+ st"'pumpControlFailAck3' did not match expected: ${pumpControlFailAck3Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val levelFailAckValue: Z = if(get_levelFailAck().nonEmpty) z"1" else z"0"
    if(!levelFailAck(levelFailAckValue)) {
      testFailures = testFailures :+ st"'levelFailAck' did not match expected: ${levelFailAckValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val steamFailAckValue: Z = if(get_steamFailAck().nonEmpty) z"1" else z"0"
    if(!steamFailAck(steamFailAckValue)) {
      testFailures = testFailures :+ st"'steamFailAck' did not match expected: ${steamFailAckValue} events were in the outgoing event queue"
    }

    assert(testFailures.isEmpty, st"${(testFailures, "\n")}".render)
  }


  // setter for in EventDataPort
  def put_opMode(value : BoilerControl.OpMode.Type): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.opMode_Id, BoilerControl.OpMode_Payload(value))
  }

  // setter for in EventPort
  def put_pumpFail0(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpFail0_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpFail1(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpFail1_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpFail2(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpFail2_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpFail3(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpFail3_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlFail0(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpControlFail0_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlFail1(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpControlFail1_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlFail2(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpControlFail2_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlFail3(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpControlFail3_Id, art.Empty())
  }

  // setter for in EventPort
  def put_levelFail(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.levelFail_Id, art.Empty())
  }

  // setter for in EventPort
  def put_steamFail(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.steamFail_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpRepairAck0(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpRepairAck0_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpRepairAck1(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpRepairAck1_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpRepairAck2(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpRepairAck2_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpRepairAck3(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpRepairAck3_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlRepairAck0(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpControlRepairAck0_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlRepairAck1(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpControlRepairAck1_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlRepairAck2(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpControlRepairAck2_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlRepairAck3(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.pumpControlRepairAck3_Id, art.Empty())
  }

  // setter for in EventPort
  def put_levelRepairAck(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.levelRepairAck_Id, art.Empty())
  }

  // setter for in EventPort
  def put_steamRepairAck(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.operational_api.steamRepairAck_Id, art.Empty())
  }

  // getter for out EventPort
  def get_stop(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_stop_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port stop.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_stop_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.stop_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpRepair0(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpRepair0_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpRepair0.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpRepair0_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpRepair0_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpRepair1(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpRepair1_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpRepair1.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpRepair1_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpRepair1_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpRepair2(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpRepair2_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpRepair2.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpRepair2_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpRepair2_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpRepair3(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpRepair3_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpRepair3.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpRepair3_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpRepair3_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlRepair0(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlRepair0_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlRepair0.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlRepair0_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpControlRepair0_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlRepair1(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlRepair1_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlRepair1.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlRepair1_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpControlRepair1_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlRepair2(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlRepair2_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlRepair2.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlRepair2_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpControlRepair2_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlRepair3(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlRepair3_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlRepair3.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlRepair3_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpControlRepair3_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_levelRepair(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_levelRepair_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port levelRepair.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_levelRepair_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.levelRepair_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_steamRepair(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_steamRepair_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port steamRepair.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_steamRepair_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.steamRepair_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpFailAck0(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpFailAck0_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpFailAck0.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpFailAck0_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpFailAck0_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpFailAck1(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpFailAck1_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpFailAck1.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpFailAck1_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpFailAck1_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpFailAck2(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpFailAck2_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpFailAck2.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpFailAck2_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpFailAck2_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpFailAck3(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpFailAck3_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpFailAck3.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpFailAck3_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpFailAck3_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlFailAck0(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlFailAck0_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlFailAck0.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlFailAck0_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpControlFailAck0_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlFailAck1(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlFailAck1_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlFailAck1.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlFailAck1_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpControlFailAck1_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlFailAck2(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlFailAck2_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlFailAck2.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlFailAck2_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpControlFailAck2_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlFailAck3(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlFailAck3_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlFailAck3.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlFailAck3_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.pumpControlFailAck3_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_levelFailAck(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_levelFailAck_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port levelFailAck.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_levelFailAck_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.levelFailAck_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_steamFailAck(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_steamFailAck_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port steamFailAck.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_steamFailAck_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_desk.initialization_api.steamFailAck_Id).asInstanceOf[Option[art.Empty]]
  }

}
