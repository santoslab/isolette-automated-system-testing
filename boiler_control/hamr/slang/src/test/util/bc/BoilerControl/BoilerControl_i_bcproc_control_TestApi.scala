// #Sireum

package bc.BoilerControl

import org.sireum._
import art.Art
import bc._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun
@msig trait BoilerControl_i_bcproc_control_TestApi {

  def BeforeEntrypoint(): Unit = {
    Art.initTest(Arch.BoilerControlSystem_i_Instance_bcproc_control)
  }

  def AfterEntrypoint(): Unit = {
    Art.finalizeTest(Arch.BoilerControlSystem_i_Instance_bcproc_control)
  }

  def testCompute(): Unit = {
    Art.manuallyClearOutput()
    Art.testCompute(Arch.BoilerControlSystem_i_Instance_bcproc_control)
  }

  def testInitialise(): Unit = {
    Art.manuallyClearOutput()
    Art.testInitialise(Arch.BoilerControlSystem_i_Instance_bcproc_control)
  }

  /** helper function to set the values of all input ports.
   * @param pumpOpen0 payloads for event data port pumpOpen0.
   *   ART currently supports single element event data queues so
   *   only the last element of pumpOpen0 will be used
   * @param pumpOpen1 payloads for event data port pumpOpen1.
   *   ART currently supports single element event data queues so
   *   only the last element of pumpOpen1 will be used
   * @param pumpOpen2 payloads for event data port pumpOpen2.
   *   ART currently supports single element event data queues so
   *   only the last element of pumpOpen2 will be used
   * @param pumpOpen3 payloads for event data port pumpOpen3.
   *   ART currently supports single element event data queues so
   *   only the last element of pumpOpen3 will be used
   * @param pumpFlow0 payloads for event data port pumpFlow0.
   *   ART currently supports single element event data queues so
   *   only the last element of pumpFlow0 will be used
   * @param pumpFlow1 payloads for event data port pumpFlow1.
   *   ART currently supports single element event data queues so
   *   only the last element of pumpFlow1 will be used
   * @param pumpFlow2 payloads for event data port pumpFlow2.
   *   ART currently supports single element event data queues so
   *   only the last element of pumpFlow2 will be used
   * @param pumpFlow3 payloads for event data port pumpFlow3.
   *   ART currently supports single element event data queues so
   *   only the last element of pumpFlow3 will be used
   * @param waterLevel payloads for event data port waterLevel.
   *   ART currently supports single element event data queues so
   *   only the last element of waterLevel will be used
   * @param steamRate payloads for event data port steamRate.
   *   ART currently supports single element event data queues so
   *   only the last element of steamRate will be used
   * @param stop the number of events to place in the stop event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param boilerWaiting the number of events to place in the boilerWaiting event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param boilerReady the number of events to place in the boilerReady event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param waterMeterReady the number of events to place in the waterMeterReady event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlReady0 the number of events to place in the pumpControlReady0 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlReady1 the number of events to place in the pumpControlReady1 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlReady2 the number of events to place in the pumpControlReady2 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlReady3 the number of events to place in the pumpControlReady3 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param steamMeterReady the number of events to place in the steamMeterReady event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpRepair0 the number of events to place in the pumpRepair0 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpRepair1 the number of events to place in the pumpRepair1 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpRepair2 the number of events to place in the pumpRepair2 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpRepair3 the number of events to place in the pumpRepair3 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlRepair0 the number of events to place in the pumpControlRepair0 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlRepair1 the number of events to place in the pumpControlRepair1 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlRepair2 the number of events to place in the pumpControlRepair2 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlRepair3 the number of events to place in the pumpControlRepair3 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param levelRepair the number of events to place in the levelRepair event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param steamRepair the number of events to place in the steamRepair event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpFailAck0 the number of events to place in the pumpFailAck0 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpFailAck1 the number of events to place in the pumpFailAck1 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpFailAck2 the number of events to place in the pumpFailAck2 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpFailAck3 the number of events to place in the pumpFailAck3 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlFailAck0 the number of events to place in the pumpControlFailAck0 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlFailAck1 the number of events to place in the pumpControlFailAck1 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlFailAck2 the number of events to place in the pumpControlFailAck2 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pumpControlFailAck3 the number of events to place in the pumpControlFailAck3 event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param levelFailAck the number of events to place in the levelFailAck event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param steamFailAck the number of events to place in the steamFailAck event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   */
  def put_concrete_inputs(pumpOpen0 : ISZ[Base_Types.Boolean],
                          pumpOpen1 : ISZ[Base_Types.Boolean],
                          pumpOpen2 : ISZ[Base_Types.Boolean],
                          pumpOpen3 : ISZ[Base_Types.Boolean],
                          pumpFlow0 : ISZ[Base_Types.Boolean],
                          pumpFlow1 : ISZ[Base_Types.Boolean],
                          pumpFlow2 : ISZ[Base_Types.Boolean],
                          pumpFlow3 : ISZ[Base_Types.Boolean],
                          waterLevel : ISZ[Base_Types.Float_32],
                          steamRate : ISZ[Base_Types.Float_32],
                          stop : Z,
                          boilerWaiting : Z,
                          boilerReady : Z,
                          waterMeterReady : Z,
                          pumpControlReady0 : Z,
                          pumpControlReady1 : Z,
                          pumpControlReady2 : Z,
                          pumpControlReady3 : Z,
                          steamMeterReady : Z,
                          pumpRepair0 : Z,
                          pumpRepair1 : Z,
                          pumpRepair2 : Z,
                          pumpRepair3 : Z,
                          pumpControlRepair0 : Z,
                          pumpControlRepair1 : Z,
                          pumpControlRepair2 : Z,
                          pumpControlRepair3 : Z,
                          levelRepair : Z,
                          steamRepair : Z,
                          pumpFailAck0 : Z,
                          pumpFailAck1 : Z,
                          pumpFailAck2 : Z,
                          pumpFailAck3 : Z,
                          pumpControlFailAck0 : Z,
                          pumpControlFailAck1 : Z,
                          pumpControlFailAck2 : Z,
                          pumpControlFailAck3 : Z,
                          levelFailAck : Z,
                          steamFailAck : Z): Unit = {
    for(v <- pumpOpen0){
      put_pumpOpen0(v)
    }
    for(v <- pumpOpen1){
      put_pumpOpen1(v)
    }
    for(v <- pumpOpen2){
      put_pumpOpen2(v)
    }
    for(v <- pumpOpen3){
      put_pumpOpen3(v)
    }
    for(v <- pumpFlow0){
      put_pumpFlow0(v)
    }
    for(v <- pumpFlow1){
      put_pumpFlow1(v)
    }
    for(v <- pumpFlow2){
      put_pumpFlow2(v)
    }
    for(v <- pumpFlow3){
      put_pumpFlow3(v)
    }
    for(v <- waterLevel){
      put_waterLevel(v)
    }
    for(v <- steamRate){
      put_steamRate(v)
    }
    for(i <- 0 until stop) {
      put_stop()
    }
    for(i <- 0 until boilerWaiting) {
      put_boilerWaiting()
    }
    for(i <- 0 until boilerReady) {
      put_boilerReady()
    }
    for(i <- 0 until waterMeterReady) {
      put_waterMeterReady()
    }
    for(i <- 0 until pumpControlReady0) {
      put_pumpControlReady0()
    }
    for(i <- 0 until pumpControlReady1) {
      put_pumpControlReady1()
    }
    for(i <- 0 until pumpControlReady2) {
      put_pumpControlReady2()
    }
    for(i <- 0 until pumpControlReady3) {
      put_pumpControlReady3()
    }
    for(i <- 0 until steamMeterReady) {
      put_steamMeterReady()
    }
    for(i <- 0 until pumpRepair0) {
      put_pumpRepair0()
    }
    for(i <- 0 until pumpRepair1) {
      put_pumpRepair1()
    }
    for(i <- 0 until pumpRepair2) {
      put_pumpRepair2()
    }
    for(i <- 0 until pumpRepair3) {
      put_pumpRepair3()
    }
    for(i <- 0 until pumpControlRepair0) {
      put_pumpControlRepair0()
    }
    for(i <- 0 until pumpControlRepair1) {
      put_pumpControlRepair1()
    }
    for(i <- 0 until pumpControlRepair2) {
      put_pumpControlRepair2()
    }
    for(i <- 0 until pumpControlRepair3) {
      put_pumpControlRepair3()
    }
    for(i <- 0 until levelRepair) {
      put_levelRepair()
    }
    for(i <- 0 until steamRepair) {
      put_steamRepair()
    }
    for(i <- 0 until pumpFailAck0) {
      put_pumpFailAck0()
    }
    for(i <- 0 until pumpFailAck1) {
      put_pumpFailAck1()
    }
    for(i <- 0 until pumpFailAck2) {
      put_pumpFailAck2()
    }
    for(i <- 0 until pumpFailAck3) {
      put_pumpFailAck3()
    }
    for(i <- 0 until pumpControlFailAck0) {
      put_pumpControlFailAck0()
    }
    for(i <- 0 until pumpControlFailAck1) {
      put_pumpControlFailAck1()
    }
    for(i <- 0 until pumpControlFailAck2) {
      put_pumpControlFailAck2()
    }
    for(i <- 0 until pumpControlFailAck3) {
      put_pumpControlFailAck3()
    }
    for(i <- 0 until levelFailAck) {
      put_levelFailAck()
    }
    for(i <- 0 until steamFailAck) {
      put_steamFailAck()
    }
  }


  /** helper function to check BoilerControl_i_bcproc_control's
   * output ports.  Use named arguments to check subsets of the output ports.
   * @param opMode method that will be called with the payloads to be sent
   *        on the outgoing event data port 'opMode'.
   * @param openPump0 method that will be called with the payloads to be sent
   *        on the outgoing event data port 'openPump0'.
   * @param openPump1 method that will be called with the payloads to be sent
   *        on the outgoing event data port 'openPump1'.
   * @param openPump2 method that will be called with the payloads to be sent
   *        on the outgoing event data port 'openPump2'.
   * @param openPump3 method that will be called with the payloads to be sent
   *        on the outgoing event data port 'openPump3'.
   * @param ready method that will be called with the number of events to be sent
   *        on the outgoing event port 'ready'.
   * @param valve method that will be called with the number of events to be sent
   *        on the outgoing event port 'valve'.
   * @param pumpFail0 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpFail0'.
   * @param pumpFail1 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpFail1'.
   * @param pumpFail2 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpFail2'.
   * @param pumpFail3 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpFail3'.
   * @param pumpControlFail0 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlFail0'.
   * @param pumpControlFail1 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlFail1'.
   * @param pumpControlFail2 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlFail2'.
   * @param pumpControlFail3 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlFail3'.
   * @param levelFail method that will be called with the number of events to be sent
   *        on the outgoing event port 'levelFail'.
   * @param steamFail method that will be called with the number of events to be sent
   *        on the outgoing event port 'steamFail'.
   * @param pumpRepairAck0 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpRepairAck0'.
   * @param pumpRepairAck1 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpRepairAck1'.
   * @param pumpRepairAck2 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpRepairAck2'.
   * @param pumpRepairAck3 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpRepairAck3'.
   * @param pumpControlRepairAck0 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlRepairAck0'.
   * @param pumpControlRepairAck1 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlRepairAck1'.
   * @param pumpControlRepairAck2 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlRepairAck2'.
   * @param pumpControlRepairAck3 method that will be called with the number of events to be sent
   *        on the outgoing event port 'pumpControlRepairAck3'.
   * @param levelRepairAck method that will be called with the number of events to be sent
   *        on the outgoing event port 'levelRepairAck'.
   * @param steamRepairAck method that will be called with the number of events to be sent
   *        on the outgoing event port 'steamRepairAck'.
   */
  def check_concrete_output(opMode: ISZ[BoilerControl.OpMode.Type] => B,
                            openPump0: ISZ[Base_Types.Boolean] => B,
                            openPump1: ISZ[Base_Types.Boolean] => B,
                            openPump2: ISZ[Base_Types.Boolean] => B,
                            openPump3: ISZ[Base_Types.Boolean] => B,
                            ready: Z => B,
                            valve: Z => B,
                            pumpFail0: Z => B,
                            pumpFail1: Z => B,
                            pumpFail2: Z => B,
                            pumpFail3: Z => B,
                            pumpControlFail0: Z => B,
                            pumpControlFail1: Z => B,
                            pumpControlFail2: Z => B,
                            pumpControlFail3: Z => B,
                            levelFail: Z => B,
                            steamFail: Z => B,
                            pumpRepairAck0: Z => B,
                            pumpRepairAck1: Z => B,
                            pumpRepairAck2: Z => B,
                            pumpRepairAck3: Z => B,
                            pumpControlRepairAck0: Z => B,
                            pumpControlRepairAck1: Z => B,
                            pumpControlRepairAck2: Z => B,
                            pumpControlRepairAck3: Z => B,
                            levelRepairAck: Z => B,
                            steamRepairAck: Z => B): Unit = {
    var testFailures: ISZ[ST] = ISZ()

    var opModeValue: ISZ[BoilerControl.OpMode.Type] = ISZ()
    // TODO: event data port getter should return all of the events/payloads
    //       received on event data ports when queue sizes > 1 support is added
    //       to ART
    if(get_opMode().nonEmpty) { opModeValue = opModeValue :+ get_opMode().get }
    if(!opMode(opModeValue)) {
      testFailures = testFailures :+ st"'opMode' did not match expected: received ${opModeValue.size} events with the following payloads ${opModeValue}"
    }
    var openPump0Value: ISZ[Base_Types.Boolean] = ISZ()
    // TODO: event data port getter should return all of the events/payloads
    //       received on event data ports when queue sizes > 1 support is added
    //       to ART
    if(get_openPump0().nonEmpty) { openPump0Value = openPump0Value :+ get_openPump0().get }
    if(!openPump0(openPump0Value)) {
      testFailures = testFailures :+ st"'openPump0' did not match expected: received ${openPump0Value.size} events with the following payloads ${openPump0Value}"
    }
    var openPump1Value: ISZ[Base_Types.Boolean] = ISZ()
    // TODO: event data port getter should return all of the events/payloads
    //       received on event data ports when queue sizes > 1 support is added
    //       to ART
    if(get_openPump1().nonEmpty) { openPump1Value = openPump1Value :+ get_openPump1().get }
    if(!openPump1(openPump1Value)) {
      testFailures = testFailures :+ st"'openPump1' did not match expected: received ${openPump1Value.size} events with the following payloads ${openPump1Value}"
    }
    var openPump2Value: ISZ[Base_Types.Boolean] = ISZ()
    // TODO: event data port getter should return all of the events/payloads
    //       received on event data ports when queue sizes > 1 support is added
    //       to ART
    if(get_openPump2().nonEmpty) { openPump2Value = openPump2Value :+ get_openPump2().get }
    if(!openPump2(openPump2Value)) {
      testFailures = testFailures :+ st"'openPump2' did not match expected: received ${openPump2Value.size} events with the following payloads ${openPump2Value}"
    }
    var openPump3Value: ISZ[Base_Types.Boolean] = ISZ()
    // TODO: event data port getter should return all of the events/payloads
    //       received on event data ports when queue sizes > 1 support is added
    //       to ART
    if(get_openPump3().nonEmpty) { openPump3Value = openPump3Value :+ get_openPump3().get }
    if(!openPump3(openPump3Value)) {
      testFailures = testFailures :+ st"'openPump3' did not match expected: received ${openPump3Value.size} events with the following payloads ${openPump3Value}"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val readyValue: Z = if(get_ready().nonEmpty) z"1" else z"0"
    if(!ready(readyValue)) {
      testFailures = testFailures :+ st"'ready' did not match expected: ${readyValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val valveValue: Z = if(get_valve().nonEmpty) z"1" else z"0"
    if(!valve(valveValue)) {
      testFailures = testFailures :+ st"'valve' did not match expected: ${valveValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpFail0Value: Z = if(get_pumpFail0().nonEmpty) z"1" else z"0"
    if(!pumpFail0(pumpFail0Value)) {
      testFailures = testFailures :+ st"'pumpFail0' did not match expected: ${pumpFail0Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpFail1Value: Z = if(get_pumpFail1().nonEmpty) z"1" else z"0"
    if(!pumpFail1(pumpFail1Value)) {
      testFailures = testFailures :+ st"'pumpFail1' did not match expected: ${pumpFail1Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpFail2Value: Z = if(get_pumpFail2().nonEmpty) z"1" else z"0"
    if(!pumpFail2(pumpFail2Value)) {
      testFailures = testFailures :+ st"'pumpFail2' did not match expected: ${pumpFail2Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpFail3Value: Z = if(get_pumpFail3().nonEmpty) z"1" else z"0"
    if(!pumpFail3(pumpFail3Value)) {
      testFailures = testFailures :+ st"'pumpFail3' did not match expected: ${pumpFail3Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlFail0Value: Z = if(get_pumpControlFail0().nonEmpty) z"1" else z"0"
    if(!pumpControlFail0(pumpControlFail0Value)) {
      testFailures = testFailures :+ st"'pumpControlFail0' did not match expected: ${pumpControlFail0Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlFail1Value: Z = if(get_pumpControlFail1().nonEmpty) z"1" else z"0"
    if(!pumpControlFail1(pumpControlFail1Value)) {
      testFailures = testFailures :+ st"'pumpControlFail1' did not match expected: ${pumpControlFail1Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlFail2Value: Z = if(get_pumpControlFail2().nonEmpty) z"1" else z"0"
    if(!pumpControlFail2(pumpControlFail2Value)) {
      testFailures = testFailures :+ st"'pumpControlFail2' did not match expected: ${pumpControlFail2Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlFail3Value: Z = if(get_pumpControlFail3().nonEmpty) z"1" else z"0"
    if(!pumpControlFail3(pumpControlFail3Value)) {
      testFailures = testFailures :+ st"'pumpControlFail3' did not match expected: ${pumpControlFail3Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val levelFailValue: Z = if(get_levelFail().nonEmpty) z"1" else z"0"
    if(!levelFail(levelFailValue)) {
      testFailures = testFailures :+ st"'levelFail' did not match expected: ${levelFailValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val steamFailValue: Z = if(get_steamFail().nonEmpty) z"1" else z"0"
    if(!steamFail(steamFailValue)) {
      testFailures = testFailures :+ st"'steamFail' did not match expected: ${steamFailValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpRepairAck0Value: Z = if(get_pumpRepairAck0().nonEmpty) z"1" else z"0"
    if(!pumpRepairAck0(pumpRepairAck0Value)) {
      testFailures = testFailures :+ st"'pumpRepairAck0' did not match expected: ${pumpRepairAck0Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpRepairAck1Value: Z = if(get_pumpRepairAck1().nonEmpty) z"1" else z"0"
    if(!pumpRepairAck1(pumpRepairAck1Value)) {
      testFailures = testFailures :+ st"'pumpRepairAck1' did not match expected: ${pumpRepairAck1Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpRepairAck2Value: Z = if(get_pumpRepairAck2().nonEmpty) z"1" else z"0"
    if(!pumpRepairAck2(pumpRepairAck2Value)) {
      testFailures = testFailures :+ st"'pumpRepairAck2' did not match expected: ${pumpRepairAck2Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpRepairAck3Value: Z = if(get_pumpRepairAck3().nonEmpty) z"1" else z"0"
    if(!pumpRepairAck3(pumpRepairAck3Value)) {
      testFailures = testFailures :+ st"'pumpRepairAck3' did not match expected: ${pumpRepairAck3Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlRepairAck0Value: Z = if(get_pumpControlRepairAck0().nonEmpty) z"1" else z"0"
    if(!pumpControlRepairAck0(pumpControlRepairAck0Value)) {
      testFailures = testFailures :+ st"'pumpControlRepairAck0' did not match expected: ${pumpControlRepairAck0Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlRepairAck1Value: Z = if(get_pumpControlRepairAck1().nonEmpty) z"1" else z"0"
    if(!pumpControlRepairAck1(pumpControlRepairAck1Value)) {
      testFailures = testFailures :+ st"'pumpControlRepairAck1' did not match expected: ${pumpControlRepairAck1Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlRepairAck2Value: Z = if(get_pumpControlRepairAck2().nonEmpty) z"1" else z"0"
    if(!pumpControlRepairAck2(pumpControlRepairAck2Value)) {
      testFailures = testFailures :+ st"'pumpControlRepairAck2' did not match expected: ${pumpControlRepairAck2Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pumpControlRepairAck3Value: Z = if(get_pumpControlRepairAck3().nonEmpty) z"1" else z"0"
    if(!pumpControlRepairAck3(pumpControlRepairAck3Value)) {
      testFailures = testFailures :+ st"'pumpControlRepairAck3' did not match expected: ${pumpControlRepairAck3Value} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val levelRepairAckValue: Z = if(get_levelRepairAck().nonEmpty) z"1" else z"0"
    if(!levelRepairAck(levelRepairAckValue)) {
      testFailures = testFailures :+ st"'levelRepairAck' did not match expected: ${levelRepairAckValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val steamRepairAckValue: Z = if(get_steamRepairAck().nonEmpty) z"1" else z"0"
    if(!steamRepairAck(steamRepairAckValue)) {
      testFailures = testFailures :+ st"'steamRepairAck' did not match expected: ${steamRepairAckValue} events were in the outgoing event queue"
    }

    assert(testFailures.isEmpty, st"${(testFailures, "\n")}".render)
  }


  // setter for in EventDataPort
  def put_pumpOpen0(value : Base_Types.Boolean): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpOpen0_Id, Base_Types.Boolean_Payload(value))
  }

  // setter for in EventDataPort
  def put_pumpOpen1(value : Base_Types.Boolean): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpOpen1_Id, Base_Types.Boolean_Payload(value))
  }

  // setter for in EventDataPort
  def put_pumpOpen2(value : Base_Types.Boolean): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpOpen2_Id, Base_Types.Boolean_Payload(value))
  }

  // setter for in EventDataPort
  def put_pumpOpen3(value : Base_Types.Boolean): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpOpen3_Id, Base_Types.Boolean_Payload(value))
  }

  // setter for in EventDataPort
  def put_pumpFlow0(value : Base_Types.Boolean): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpFlow0_Id, Base_Types.Boolean_Payload(value))
  }

  // setter for in EventDataPort
  def put_pumpFlow1(value : Base_Types.Boolean): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpFlow1_Id, Base_Types.Boolean_Payload(value))
  }

  // setter for in EventDataPort
  def put_pumpFlow2(value : Base_Types.Boolean): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpFlow2_Id, Base_Types.Boolean_Payload(value))
  }

  // setter for in EventDataPort
  def put_pumpFlow3(value : Base_Types.Boolean): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpFlow3_Id, Base_Types.Boolean_Payload(value))
  }

  // setter for in EventDataPort
  def put_waterLevel(value : Base_Types.Float_32): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.waterLevel_Id, Base_Types.Float_32_Payload(value))
  }

  // setter for in EventDataPort
  def put_steamRate(value : Base_Types.Float_32): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.steamRate_Id, Base_Types.Float_32_Payload(value))
  }

  // setter for in EventPort
  def put_stop(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.stop_Id, art.Empty())
  }

  // setter for in EventPort
  def put_boilerWaiting(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.boilerWaiting_Id, art.Empty())
  }

  // setter for in EventPort
  def put_boilerReady(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.boilerReady_Id, art.Empty())
  }

  // setter for in EventPort
  def put_waterMeterReady(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.waterMeterReady_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlReady0(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpControlReady0_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlReady1(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpControlReady1_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlReady2(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpControlReady2_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlReady3(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpControlReady3_Id, art.Empty())
  }

  // setter for in EventPort
  def put_steamMeterReady(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.steamMeterReady_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpRepair0(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpRepair0_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpRepair1(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpRepair1_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpRepair2(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpRepair2_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpRepair3(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpRepair3_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlRepair0(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpControlRepair0_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlRepair1(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpControlRepair1_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlRepair2(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpControlRepair2_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlRepair3(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpControlRepair3_Id, art.Empty())
  }

  // setter for in EventPort
  def put_levelRepair(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.levelRepair_Id, art.Empty())
  }

  // setter for in EventPort
  def put_steamRepair(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.steamRepair_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpFailAck0(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpFailAck0_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpFailAck1(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpFailAck1_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpFailAck2(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpFailAck2_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpFailAck3(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpFailAck3_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlFailAck0(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpControlFailAck0_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlFailAck1(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpControlFailAck1_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlFailAck2(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpControlFailAck2_Id, art.Empty())
  }

  // setter for in EventPort
  def put_pumpControlFailAck3(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.pumpControlFailAck3_Id, art.Empty())
  }

  // setter for in EventPort
  def put_levelFailAck(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.levelFailAck_Id, art.Empty())
  }

  // setter for in EventPort
  def put_steamFailAck(): Unit = {
    Art.insertInInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.operational_api.steamFailAck_Id, art.Empty())
  }

  // getter for out EventDataPort
  def get_opMode(): Option[BoilerControl.OpMode.Type] = {
    val value: Option[BoilerControl.OpMode.Type] = get_opMode_payload() match {
      case Some(BoilerControl.OpMode_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port opMode.  Expecting 'BoilerControl.OpMode_Payload' but received ${v}")
      case _ => None[BoilerControl.OpMode.Type]()
    }
    return value
  }

  // payload getter for out EventDataPort
  def get_opMode_payload(): Option[BoilerControl.OpMode_Payload] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.opMode_Id).asInstanceOf[Option[BoilerControl.OpMode_Payload]]
  }

  // getter for out EventDataPort
  def get_openPump0(): Option[Base_Types.Boolean] = {
    val value: Option[Base_Types.Boolean] = get_openPump0_payload() match {
      case Some(Base_Types.Boolean_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port openPump0.  Expecting 'Base_Types.Boolean_Payload' but received ${v}")
      case _ => None[Base_Types.Boolean]()
    }
    return value
  }

  // payload getter for out EventDataPort
  def get_openPump0_payload(): Option[Base_Types.Boolean_Payload] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.openPump0_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]
  }

  // getter for out EventDataPort
  def get_openPump1(): Option[Base_Types.Boolean] = {
    val value: Option[Base_Types.Boolean] = get_openPump1_payload() match {
      case Some(Base_Types.Boolean_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port openPump1.  Expecting 'Base_Types.Boolean_Payload' but received ${v}")
      case _ => None[Base_Types.Boolean]()
    }
    return value
  }

  // payload getter for out EventDataPort
  def get_openPump1_payload(): Option[Base_Types.Boolean_Payload] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.openPump1_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]
  }

  // getter for out EventDataPort
  def get_openPump2(): Option[Base_Types.Boolean] = {
    val value: Option[Base_Types.Boolean] = get_openPump2_payload() match {
      case Some(Base_Types.Boolean_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port openPump2.  Expecting 'Base_Types.Boolean_Payload' but received ${v}")
      case _ => None[Base_Types.Boolean]()
    }
    return value
  }

  // payload getter for out EventDataPort
  def get_openPump2_payload(): Option[Base_Types.Boolean_Payload] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.openPump2_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]
  }

  // getter for out EventDataPort
  def get_openPump3(): Option[Base_Types.Boolean] = {
    val value: Option[Base_Types.Boolean] = get_openPump3_payload() match {
      case Some(Base_Types.Boolean_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port openPump3.  Expecting 'Base_Types.Boolean_Payload' but received ${v}")
      case _ => None[Base_Types.Boolean]()
    }
    return value
  }

  // payload getter for out EventDataPort
  def get_openPump3_payload(): Option[Base_Types.Boolean_Payload] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.openPump3_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]
  }

  // getter for out EventPort
  def get_ready(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_ready_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port ready.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_ready_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.ready_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_valve(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_valve_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port valve.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_valve_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.valve_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpFail0(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpFail0_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpFail0.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpFail0_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpFail0_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpFail1(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpFail1_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpFail1.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpFail1_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpFail1_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpFail2(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpFail2_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpFail2.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpFail2_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpFail2_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpFail3(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpFail3_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpFail3.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpFail3_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpFail3_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlFail0(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlFail0_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlFail0.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlFail0_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpControlFail0_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlFail1(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlFail1_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlFail1.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlFail1_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpControlFail1_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlFail2(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlFail2_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlFail2.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlFail2_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpControlFail2_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlFail3(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlFail3_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlFail3.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlFail3_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpControlFail3_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_levelFail(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_levelFail_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port levelFail.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_levelFail_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.levelFail_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_steamFail(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_steamFail_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port steamFail.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_steamFail_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.steamFail_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpRepairAck0(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpRepairAck0_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpRepairAck0.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpRepairAck0_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpRepairAck0_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpRepairAck1(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpRepairAck1_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpRepairAck1.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpRepairAck1_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpRepairAck1_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpRepairAck2(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpRepairAck2_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpRepairAck2.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpRepairAck2_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpRepairAck2_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpRepairAck3(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpRepairAck3_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpRepairAck3.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpRepairAck3_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpRepairAck3_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlRepairAck0(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlRepairAck0_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlRepairAck0.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlRepairAck0_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpControlRepairAck0_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlRepairAck1(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlRepairAck1_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlRepairAck1.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlRepairAck1_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpControlRepairAck1_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlRepairAck2(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlRepairAck2_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlRepairAck2.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlRepairAck2_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpControlRepairAck2_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_pumpControlRepairAck3(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pumpControlRepairAck3_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port pumpControlRepairAck3.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pumpControlRepairAck3_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.pumpControlRepairAck3_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_levelRepairAck(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_levelRepairAck_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port levelRepairAck.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_levelRepairAck_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.levelRepairAck_Id).asInstanceOf[Option[art.Empty]]
  }

  // getter for out EventPort
  def get_steamRepairAck(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_steamRepairAck_payload() match {
      case Some(art.Empty()) => Some(art.Empty())
      case Some(v) => halt(s"Unexpected payload on port steamRepairAck.  Expecting 'art.Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_steamRepairAck_payload(): Option[art.Empty] = {
    return Art.observeOutInfrastructurePort(Arch.BoilerControlSystem_i_Instance_bcproc_control.initialization_api.steamRepairAck_Id).asInstanceOf[Option[art.Empty]]
  }

}
