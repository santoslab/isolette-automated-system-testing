// #Sireum

package bc.BoilerControl

import org.sireum._
import bc._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun
object BoilerControl_i_bcproc_control_GumboX {
  /** Initialize Entrypoint Contract
    *
    * guarantee REQ_BCON_INIT_1
    *   OpMode should be sent initially, it should contain an init payload. mode should be init.
    * @param mode post-state state variable
    * @param api_opMode outgoing event data port
    */
  @strictpure def initialize_REQ_BCON_INIT_1 (
      mode: BoilerControl.OpMode.Type,
      api_opMode: Option[BoilerControl.OpMode.Type]): B =
    api_opMode.nonEmpty &&
      mode == BoilerControl.OpMode.Init

  /** Initialize Entrypoint Contract
    *
    * guarantee REQ_BCON_INIT_2
    *   Other than OpMode, no other out port should be sent.
    * @param api_levelFail outgoing event port
    * @param api_levelRepairAck outgoing event port
    * @param api_pumpControlFail0 outgoing event port
    * @param api_pumpControlFail1 outgoing event port
    * @param api_pumpControlFail2 outgoing event port
    * @param api_pumpControlFail3 outgoing event port
    * @param api_pumpControlRepairAck0 outgoing event port
    * @param api_pumpControlRepairAck1 outgoing event port
    * @param api_pumpControlRepairAck2 outgoing event port
    * @param api_pumpControlRepairAck3 outgoing event port
    * @param api_pumpFail0 outgoing event port
    * @param api_pumpFail1 outgoing event port
    * @param api_pumpFail2 outgoing event port
    * @param api_pumpFail3 outgoing event port
    * @param api_pumpRepairAck0 outgoing event port
    * @param api_pumpRepairAck1 outgoing event port
    * @param api_pumpRepairAck2 outgoing event port
    * @param api_pumpRepairAck3 outgoing event port
    * @param api_ready outgoing event port
    * @param api_steamFail outgoing event port
    * @param api_steamRepairAck outgoing event port
    * @param api_valve outgoing event port
    * @param api_openPump0 outgoing event data port
    * @param api_openPump1 outgoing event data port
    * @param api_openPump2 outgoing event data port
    * @param api_openPump3 outgoing event data port
    */
  @strictpure def initialize_REQ_BCON_INIT_2 (
      api_levelFail: Option[art.Empty],
      api_levelRepairAck: Option[art.Empty],
      api_pumpControlFail0: Option[art.Empty],
      api_pumpControlFail1: Option[art.Empty],
      api_pumpControlFail2: Option[art.Empty],
      api_pumpControlFail3: Option[art.Empty],
      api_pumpControlRepairAck0: Option[art.Empty],
      api_pumpControlRepairAck1: Option[art.Empty],
      api_pumpControlRepairAck2: Option[art.Empty],
      api_pumpControlRepairAck3: Option[art.Empty],
      api_pumpFail0: Option[art.Empty],
      api_pumpFail1: Option[art.Empty],
      api_pumpFail2: Option[art.Empty],
      api_pumpFail3: Option[art.Empty],
      api_pumpRepairAck0: Option[art.Empty],
      api_pumpRepairAck1: Option[art.Empty],
      api_pumpRepairAck2: Option[art.Empty],
      api_pumpRepairAck3: Option[art.Empty],
      api_ready: Option[art.Empty],
      api_steamFail: Option[art.Empty],
      api_steamRepairAck: Option[art.Empty],
      api_valve: Option[art.Empty],
      api_openPump0: Option[Base_Types.Boolean],
      api_openPump1: Option[Base_Types.Boolean],
      api_openPump2: Option[Base_Types.Boolean],
      api_openPump3: Option[Base_Types.Boolean]): B =
    api_openPump0.isEmpty && api_openPump1.isEmpty &&
      api_openPump2.isEmpty &&
      api_openPump3.isEmpty &&
      api_ready.isEmpty &&
      api_valve.isEmpty &&
      api_pumpFail0.isEmpty &&
      api_pumpFail1.isEmpty &&
      api_pumpFail2.isEmpty &&
      api_pumpFail3.isEmpty &&
      api_pumpControlFail0.isEmpty &&
      api_pumpControlFail1.isEmpty &&
      api_pumpControlFail2.isEmpty &&
      api_pumpControlFail3.isEmpty &&
      api_levelFail.isEmpty &&
      api_steamFail.isEmpty &&
      api_pumpRepairAck0.isEmpty &&
      api_pumpRepairAck1.isEmpty &&
      api_pumpRepairAck2.isEmpty &&
      api_pumpRepairAck3.isEmpty &&
      api_pumpControlRepairAck0.isEmpty &&
      api_pumpControlRepairAck1.isEmpty &&
      api_pumpControlRepairAck2.isEmpty &&
      api_pumpControlRepairAck3.isEmpty &&
      api_levelRepairAck.isEmpty &&
      api_steamRepairAck.isEmpty

  /** IEP-Guar: Initialize Entrypoint Contracts for control
    *
    * @param C post-state state variable
    * @param M1 post-state state variable
    * @param M2 post-state state variable
    * @param N1 post-state state variable
    * @param N2 post-state state variable
    * @param P post-state state variable
    * @param U1 post-state state variable
    * @param U2 post-state state variable
    * @param W post-state state variable
    * @param hasBoilerSentWaiting post-state state variable
    * @param isPump0Failing post-state state variable
    * @param isPump1Failing post-state state variable
    * @param isPump2Failing post-state state variable
    * @param isPump3Failing post-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param p0 post-state state variable
    * @param p1 post-state state variable
    * @param p2 post-state state variable
    * @param p3 post-state state variable
    * @param q post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param qc1 post-state state variable
    * @param qc2 post-state state variable
    * @param shouldUpdatePumps post-state state variable
    * @param transmissionFailure post-state state variable
    * @param v_steamRate post-state state variable
    * @param api_levelFail outgoing event port
    * @param api_levelRepairAck outgoing event port
    * @param api_pumpControlFail0 outgoing event port
    * @param api_pumpControlFail1 outgoing event port
    * @param api_pumpControlFail2 outgoing event port
    * @param api_pumpControlFail3 outgoing event port
    * @param api_pumpControlRepairAck0 outgoing event port
    * @param api_pumpControlRepairAck1 outgoing event port
    * @param api_pumpControlRepairAck2 outgoing event port
    * @param api_pumpControlRepairAck3 outgoing event port
    * @param api_pumpFail0 outgoing event port
    * @param api_pumpFail1 outgoing event port
    * @param api_pumpFail2 outgoing event port
    * @param api_pumpFail3 outgoing event port
    * @param api_pumpRepairAck0 outgoing event port
    * @param api_pumpRepairAck1 outgoing event port
    * @param api_pumpRepairAck2 outgoing event port
    * @param api_pumpRepairAck3 outgoing event port
    * @param api_ready outgoing event port
    * @param api_steamFail outgoing event port
    * @param api_steamRepairAck outgoing event port
    * @param api_valve outgoing event port
    * @param api_opMode outgoing event data port
    * @param api_openPump0 outgoing event data port
    * @param api_openPump1 outgoing event data port
    * @param api_openPump2 outgoing event data port
    * @param api_openPump3 outgoing event data port
    */
  @strictpure def initialize_IEP_Guar (
      C: Base_Types.Float_32,
      M1: Base_Types.Float_32,
      M2: Base_Types.Float_32,
      N1: Base_Types.Float_32,
      N2: Base_Types.Float_32,
      P: Base_Types.Float_32,
      U1: Base_Types.Float_32,
      U2: Base_Types.Float_32,
      W: Base_Types.Float_32,
      hasBoilerSentWaiting: Base_Types.Boolean,
      isPump0Failing: Base_Types.Boolean,
      isPump1Failing: Base_Types.Boolean,
      isPump2Failing: Base_Types.Boolean,
      isPump3Failing: Base_Types.Boolean,
      isSteamMeterFailing: Base_Types.Boolean,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      p0: Base_Types.Float_32,
      p1: Base_Types.Float_32,
      p2: Base_Types.Float_32,
      p3: Base_Types.Float_32,
      q: Base_Types.Float_32,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      qc1: Base_Types.Float_32,
      qc2: Base_Types.Float_32,
      shouldUpdatePumps: Base_Types.Boolean,
      transmissionFailure: Base_Types.Boolean,
      v_steamRate: Base_Types.Float_32,
      api_levelFail: Option[art.Empty],
      api_levelRepairAck: Option[art.Empty],
      api_pumpControlFail0: Option[art.Empty],
      api_pumpControlFail1: Option[art.Empty],
      api_pumpControlFail2: Option[art.Empty],
      api_pumpControlFail3: Option[art.Empty],
      api_pumpControlRepairAck0: Option[art.Empty],
      api_pumpControlRepairAck1: Option[art.Empty],
      api_pumpControlRepairAck2: Option[art.Empty],
      api_pumpControlRepairAck3: Option[art.Empty],
      api_pumpFail0: Option[art.Empty],
      api_pumpFail1: Option[art.Empty],
      api_pumpFail2: Option[art.Empty],
      api_pumpFail3: Option[art.Empty],
      api_pumpRepairAck0: Option[art.Empty],
      api_pumpRepairAck1: Option[art.Empty],
      api_pumpRepairAck2: Option[art.Empty],
      api_pumpRepairAck3: Option[art.Empty],
      api_ready: Option[art.Empty],
      api_steamFail: Option[art.Empty],
      api_steamRepairAck: Option[art.Empty],
      api_valve: Option[art.Empty],
      api_opMode: Option[BoilerControl.OpMode.Type],
      api_openPump0: Option[Base_Types.Boolean],
      api_openPump1: Option[Base_Types.Boolean],
      api_openPump2: Option[Base_Types.Boolean],
      api_openPump3: Option[Base_Types.Boolean]): B =
    initialize_REQ_BCON_INIT_1(mode, api_opMode) &
    initialize_REQ_BCON_INIT_2(api_levelFail, api_levelRepairAck, api_pumpControlFail0, api_pumpControlFail1, api_pumpControlFail2, api_pumpControlFail3, api_pumpControlRepairAck0, api_pumpControlRepairAck1, api_pumpControlRepairAck2, api_pumpControlRepairAck3, api_pumpFail0, api_pumpFail1, api_pumpFail2, api_pumpFail3, api_pumpRepairAck0, api_pumpRepairAck1, api_pumpRepairAck2, api_pumpRepairAck3, api_ready, api_steamFail, api_steamRepairAck, api_valve, api_openPump0, api_openPump1, api_openPump2, api_openPump3)

  /** IEP-Post: Initialize Entrypoint Post-Condition
    *
    * @param C post-state state variable
    * @param M1 post-state state variable
    * @param M2 post-state state variable
    * @param N1 post-state state variable
    * @param N2 post-state state variable
    * @param P post-state state variable
    * @param U1 post-state state variable
    * @param U2 post-state state variable
    * @param W post-state state variable
    * @param hasBoilerSentWaiting post-state state variable
    * @param isPump0Failing post-state state variable
    * @param isPump1Failing post-state state variable
    * @param isPump2Failing post-state state variable
    * @param isPump3Failing post-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param p0 post-state state variable
    * @param p1 post-state state variable
    * @param p2 post-state state variable
    * @param p3 post-state state variable
    * @param q post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param qc1 post-state state variable
    * @param qc2 post-state state variable
    * @param shouldUpdatePumps post-state state variable
    * @param transmissionFailure post-state state variable
    * @param v_steamRate post-state state variable
    * @param api_levelFail outgoing event port
    * @param api_levelRepairAck outgoing event port
    * @param api_pumpControlFail0 outgoing event port
    * @param api_pumpControlFail1 outgoing event port
    * @param api_pumpControlFail2 outgoing event port
    * @param api_pumpControlFail3 outgoing event port
    * @param api_pumpControlRepairAck0 outgoing event port
    * @param api_pumpControlRepairAck1 outgoing event port
    * @param api_pumpControlRepairAck2 outgoing event port
    * @param api_pumpControlRepairAck3 outgoing event port
    * @param api_pumpFail0 outgoing event port
    * @param api_pumpFail1 outgoing event port
    * @param api_pumpFail2 outgoing event port
    * @param api_pumpFail3 outgoing event port
    * @param api_pumpRepairAck0 outgoing event port
    * @param api_pumpRepairAck1 outgoing event port
    * @param api_pumpRepairAck2 outgoing event port
    * @param api_pumpRepairAck3 outgoing event port
    * @param api_ready outgoing event port
    * @param api_steamFail outgoing event port
    * @param api_steamRepairAck outgoing event port
    * @param api_valve outgoing event port
    * @param api_opMode outgoing event data port
    * @param api_openPump0 outgoing event data port
    * @param api_openPump1 outgoing event data port
    * @param api_openPump2 outgoing event data port
    * @param api_openPump3 outgoing event data port
    */
  @strictpure def inititialize_IEP_Post (
      C: Base_Types.Float_32,
      M1: Base_Types.Float_32,
      M2: Base_Types.Float_32,
      N1: Base_Types.Float_32,
      N2: Base_Types.Float_32,
      P: Base_Types.Float_32,
      U1: Base_Types.Float_32,
      U2: Base_Types.Float_32,
      W: Base_Types.Float_32,
      hasBoilerSentWaiting: Base_Types.Boolean,
      isPump0Failing: Base_Types.Boolean,
      isPump1Failing: Base_Types.Boolean,
      isPump2Failing: Base_Types.Boolean,
      isPump3Failing: Base_Types.Boolean,
      isSteamMeterFailing: Base_Types.Boolean,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      p0: Base_Types.Float_32,
      p1: Base_Types.Float_32,
      p2: Base_Types.Float_32,
      p3: Base_Types.Float_32,
      q: Base_Types.Float_32,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      qc1: Base_Types.Float_32,
      qc2: Base_Types.Float_32,
      shouldUpdatePumps: Base_Types.Boolean,
      transmissionFailure: Base_Types.Boolean,
      v_steamRate: Base_Types.Float_32,
      api_levelFail: Option[art.Empty],
      api_levelRepairAck: Option[art.Empty],
      api_pumpControlFail0: Option[art.Empty],
      api_pumpControlFail1: Option[art.Empty],
      api_pumpControlFail2: Option[art.Empty],
      api_pumpControlFail3: Option[art.Empty],
      api_pumpControlRepairAck0: Option[art.Empty],
      api_pumpControlRepairAck1: Option[art.Empty],
      api_pumpControlRepairAck2: Option[art.Empty],
      api_pumpControlRepairAck3: Option[art.Empty],
      api_pumpFail0: Option[art.Empty],
      api_pumpFail1: Option[art.Empty],
      api_pumpFail2: Option[art.Empty],
      api_pumpFail3: Option[art.Empty],
      api_pumpRepairAck0: Option[art.Empty],
      api_pumpRepairAck1: Option[art.Empty],
      api_pumpRepairAck2: Option[art.Empty],
      api_pumpRepairAck3: Option[art.Empty],
      api_ready: Option[art.Empty],
      api_steamFail: Option[art.Empty],
      api_steamRepairAck: Option[art.Empty],
      api_valve: Option[art.Empty],
      api_opMode: Option[BoilerControl.OpMode.Type],
      api_openPump0: Option[Base_Types.Boolean],
      api_openPump1: Option[Base_Types.Boolean],
      api_openPump2: Option[Base_Types.Boolean],
      api_openPump3: Option[Base_Types.Boolean]): B =
    (// IEP-Guar: Initialize Entrypoint contract for control
     initialize_IEP_Guar(C, M1, M2, N1, N2, P, U1, U2, W, hasBoilerSentWaiting, isPump0Failing, isPump1Failing, isPump2Failing, isPump3Failing, isSteamMeterFailing, isWaterMeterFailing, mode, p0, p1, p2, p3, q, qa1, qa2, qc1, qc2, shouldUpdatePumps, transmissionFailure, v_steamRate, api_levelFail, api_levelRepairAck, api_pumpControlFail0, api_pumpControlFail1, api_pumpControlFail2, api_pumpControlFail3, api_pumpControlRepairAck0, api_pumpControlRepairAck1, api_pumpControlRepairAck2, api_pumpControlRepairAck3, api_pumpFail0, api_pumpFail1, api_pumpFail2, api_pumpFail3, api_pumpRepairAck0, api_pumpRepairAck1, api_pumpRepairAck2, api_pumpRepairAck3, api_ready, api_steamFail, api_steamRepairAck, api_valve, api_opMode, api_openPump0, api_openPump1, api_openPump2, api_openPump3))

  /** IEP-Post: Initialize Entrypoint Post-Condition via container
    *
    * @param post Container holding the value of incoming ports and the pre-state values of state variables
    */
  @strictpure def inititialize_IEP_Post_Container (post: BoilerControl_i_bcproc_control_PostState_Container_PS): B =
    inititialize_IEP_Post (
      C = post.C,
      M1 = post.M1,
      M2 = post.M2,
      N1 = post.N1,
      N2 = post.N2,
      P = post.P,
      U1 = post.U1,
      U2 = post.U2,
      W = post.W,
      hasBoilerSentWaiting = post.hasBoilerSentWaiting,
      isPump0Failing = post.isPump0Failing,
      isPump1Failing = post.isPump1Failing,
      isPump2Failing = post.isPump2Failing,
      isPump3Failing = post.isPump3Failing,
      isSteamMeterFailing = post.isSteamMeterFailing,
      isWaterMeterFailing = post.isWaterMeterFailing,
      mode = post.mode,
      p0 = post.p0,
      p1 = post.p1,
      p2 = post.p2,
      p3 = post.p3,
      q = post.q,
      qa1 = post.qa1,
      qa2 = post.qa2,
      qc1 = post.qc1,
      qc2 = post.qc2,
      shouldUpdatePumps = post.shouldUpdatePumps,
      transmissionFailure = post.transmissionFailure,
      v_steamRate = post.v_steamRate,
      api_levelFail = post.api_levelFail,
      api_levelRepairAck = post.api_levelRepairAck,
      api_pumpControlFail0 = post.api_pumpControlFail0,
      api_pumpControlFail1 = post.api_pumpControlFail1,
      api_pumpControlFail2 = post.api_pumpControlFail2,
      api_pumpControlFail3 = post.api_pumpControlFail3,
      api_pumpControlRepairAck0 = post.api_pumpControlRepairAck0,
      api_pumpControlRepairAck1 = post.api_pumpControlRepairAck1,
      api_pumpControlRepairAck2 = post.api_pumpControlRepairAck2,
      api_pumpControlRepairAck3 = post.api_pumpControlRepairAck3,
      api_pumpFail0 = post.api_pumpFail0,
      api_pumpFail1 = post.api_pumpFail1,
      api_pumpFail2 = post.api_pumpFail2,
      api_pumpFail3 = post.api_pumpFail3,
      api_pumpRepairAck0 = post.api_pumpRepairAck0,
      api_pumpRepairAck1 = post.api_pumpRepairAck1,
      api_pumpRepairAck2 = post.api_pumpRepairAck2,
      api_pumpRepairAck3 = post.api_pumpRepairAck3,
      api_ready = post.api_ready,
      api_steamFail = post.api_steamFail,
      api_steamRepairAck = post.api_steamRepairAck,
      api_valve = post.api_valve,
      api_opMode = post.api_opMode,
      api_openPump0 = post.api_openPump0,
      api_openPump1 = post.api_openPump1,
      api_openPump2 = post.api_openPump2,
      api_openPump3 = post.api_openPump3)

  /** guarantee REQ_BCON_COMP_1
    *   If the stop event is recieved, mode is stop.
    * @param mode post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_1(
      mode: BoilerControl.OpMode.Type,
      api_stop: Option[art.Empty]): B =
    (api_stop.nonEmpty) -->:
      (mode == BoilerControl.OpMode.Stop)

  /** guarantee REQ_BCON_COMP_2
    *   If the stop event is not recieved and if mode was not stop before, then any part that is failing will send the correct fail event.
    * @param In_mode pre-state state variable
    * @param isPump0Failing post-state state variable
    * @param isPump1Failing post-state state variable
    * @param isPump2Failing post-state state variable
    * @param isPump3Failing post-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param api_stop incoming event port
    * @param api_levelFail outgoing event port
    * @param api_pumpFail0 outgoing event port
    * @param api_pumpFail1 outgoing event port
    * @param api_pumpFail2 outgoing event port
    * @param api_pumpFail3 outgoing event port
    * @param api_steamFail outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_2(
      In_mode: BoilerControl.OpMode.Type,
      isPump0Failing: Base_Types.Boolean,
      isPump1Failing: Base_Types.Boolean,
      isPump2Failing: Base_Types.Boolean,
      isPump3Failing: Base_Types.Boolean,
      isSteamMeterFailing: Base_Types.Boolean,
      isWaterMeterFailing: Base_Types.Boolean,
      api_stop: Option[art.Empty],
      api_levelFail: Option[art.Empty],
      api_pumpFail0: Option[art.Empty],
      api_pumpFail1: Option[art.Empty],
      api_pumpFail2: Option[art.Empty],
      api_pumpFail3: Option[art.Empty],
      api_steamFail: Option[art.Empty]): B =
    (!(api_stop.nonEmpty) &&
       In_mode != BoilerControl.OpMode.Stop) -->:
      (isWaterMeterFailing ->: api_levelFail.nonEmpty &
         isSteamMeterFailing ->: api_steamFail.nonEmpty &
         isPump0Failing ->: api_pumpFail0.nonEmpty &
         isPump1Failing ->: api_pumpFail1.nonEmpty &
         isPump2Failing ->: api_pumpFail2.nonEmpty &
         isPump3Failing ->: api_pumpFail3.nonEmpty)

  /** guarantee REQ_BCON_COMP_3
    *   If the stop event is not recieved and if mode was not stop before, then P is equal to the sum of p0, p1, p2, and p3.
    * @param In_mode pre-state state variable
    * @param P post-state state variable
    * @param p0 post-state state variable
    * @param p1 post-state state variable
    * @param p2 post-state state variable
    * @param p3 post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_3(
      In_mode: BoilerControl.OpMode.Type,
      P: Base_Types.Float_32,
      p0: Base_Types.Float_32,
      p1: Base_Types.Float_32,
      p2: Base_Types.Float_32,
      p3: Base_Types.Float_32,
      api_stop: Option[art.Empty]): B =
    (!(api_stop.nonEmpty) &&
       In_mode != BoilerControl.OpMode.Stop) -->:
      (P == p0 + p1 + p2 + p3)

  /** guarantee REQ_BCON_COMP_4
    *   If the stop event is not recieved and if mode was not stop before, then qc1 and qc2 follow the formula on [508].
    * @param In_mode pre-state state variable
    * @param P post-state state variable
    * @param U1 post-state state variable
    * @param q post-state state variable
    * @param qc1 post-state state variable
    * @param qc2 post-state state variable
    * @param v_steamRate post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_4(
      In_mode: BoilerControl.OpMode.Type,
      P: Base_Types.Float_32,
      U1: Base_Types.Float_32,
      q: Base_Types.Float_32,
      qc1: Base_Types.Float_32,
      qc2: Base_Types.Float_32,
      v_steamRate: Base_Types.Float_32,
      api_stop: Option[art.Empty]): B =
    (!(api_stop.nonEmpty) &&
       In_mode != BoilerControl.OpMode.Stop) -->:
      (qc1 == q - 5.0f * v_steamRate - 12.5f * U1 + P &
         qc2 == q - 5.0f * v_steamRate + 12.5f * U1 + P)

  /** guarantee REQ_BCON_COMP_5
    *   If the stop event is not recieved and if mode was not stop before, and Water Meter is failing, then qa1 == qc1 and qa2 == qc2 [508]
    * @param In_mode pre-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param qc1 post-state state variable
    * @param qc2 post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_5(
      In_mode: BoilerControl.OpMode.Type,
      isWaterMeterFailing: Base_Types.Boolean,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      qc1: Base_Types.Float_32,
      qc2: Base_Types.Float_32,
      api_stop: Option[art.Empty]): B =
    (!(api_stop.nonEmpty) &&
       In_mode != BoilerControl.OpMode.Stop) -->:
      (isWaterMeterFailing ->: (qa1 == qc1 &
          qa2 == qc2))

  /** guarantee REQ_BCON_COMP_6
    *   If the stop event is not recieved and if mode was not stop before, and Water Meter is not failing, then qa1 == q and qa2 == q [508]
    * @param In_mode pre-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param q post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_6(
      In_mode: BoilerControl.OpMode.Type,
      isWaterMeterFailing: Base_Types.Boolean,
      q: Base_Types.Float_32,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      api_stop: Option[art.Empty]): B =
    (!(api_stop.nonEmpty) &&
       In_mode != BoilerControl.OpMode.Stop) -->:
      (!isWaterMeterFailing ->: (qa1 == q &
          qa2 == q))

  /** guarantee REQ_BCON_COMP_7
    *   Always, an OpMode event should be sent with the current value of mode.
    * @param mode post-state state variable
    * @param api_opMode outgoing event data port
    */
  @strictpure def compute_case_REQ_BCON_COMP_7(
      mode: BoilerControl.OpMode.Type,
      api_opMode: Option[BoilerControl.OpMode.Type]): B =
    (T) -->:
      (api_opMode.nonEmpty &
         api_opMode.get == mode)

  /** guarantee REQ_BCON_COMP_8
    *   If in mode is Stop. Then no ports other than OpMode should be populated.
    * @param In_mode pre-state state variable
    * @param api_levelFail outgoing event port
    * @param api_levelRepairAck outgoing event port
    * @param api_pumpControlFail0 outgoing event port
    * @param api_pumpControlFail1 outgoing event port
    * @param api_pumpControlFail2 outgoing event port
    * @param api_pumpControlFail3 outgoing event port
    * @param api_pumpFail0 outgoing event port
    * @param api_pumpFail1 outgoing event port
    * @param api_pumpFail2 outgoing event port
    * @param api_pumpFail3 outgoing event port
    * @param api_pumpRepairAck0 outgoing event port
    * @param api_pumpRepairAck1 outgoing event port
    * @param api_pumpRepairAck2 outgoing event port
    * @param api_pumpRepairAck3 outgoing event port
    * @param api_ready outgoing event port
    * @param api_steamFail outgoing event port
    * @param api_steamRepairAck outgoing event port
    * @param api_valve outgoing event port
    * @param api_opMode outgoing event data port
    * @param api_openPump0 outgoing event data port
    * @param api_openPump1 outgoing event data port
    * @param api_openPump2 outgoing event data port
    * @param api_openPump3 outgoing event data port
    */
  @strictpure def compute_case_REQ_BCON_COMP_8(
      In_mode: BoilerControl.OpMode.Type,
      api_levelFail: Option[art.Empty],
      api_levelRepairAck: Option[art.Empty],
      api_pumpControlFail0: Option[art.Empty],
      api_pumpControlFail1: Option[art.Empty],
      api_pumpControlFail2: Option[art.Empty],
      api_pumpControlFail3: Option[art.Empty],
      api_pumpFail0: Option[art.Empty],
      api_pumpFail1: Option[art.Empty],
      api_pumpFail2: Option[art.Empty],
      api_pumpFail3: Option[art.Empty],
      api_pumpRepairAck0: Option[art.Empty],
      api_pumpRepairAck1: Option[art.Empty],
      api_pumpRepairAck2: Option[art.Empty],
      api_pumpRepairAck3: Option[art.Empty],
      api_ready: Option[art.Empty],
      api_steamFail: Option[art.Empty],
      api_steamRepairAck: Option[art.Empty],
      api_valve: Option[art.Empty],
      api_opMode: Option[BoilerControl.OpMode.Type],
      api_openPump0: Option[Base_Types.Boolean],
      api_openPump1: Option[Base_Types.Boolean],
      api_openPump2: Option[Base_Types.Boolean],
      api_openPump3: Option[Base_Types.Boolean]): B =
    (In_mode == BoilerControl.OpMode.Stop) -->:
      (api_opMode.nonEmpty & api_openPump0.isEmpty &
         api_openPump1.isEmpty &
         api_openPump2.isEmpty &
         api_openPump3.isEmpty &
         api_ready.isEmpty &
         api_valve.isEmpty &
         api_pumpFail0.isEmpty &
         api_pumpFail1.isEmpty &
         api_pumpFail2.isEmpty &
         api_pumpFail3.isEmpty &
         api_pumpControlFail0.isEmpty &
         api_pumpControlFail1.isEmpty &
         api_pumpControlFail2.isEmpty &
         api_pumpControlFail3.isEmpty &
         api_levelFail.isEmpty &
         api_steamFail.isEmpty &
         api_pumpRepairAck0.isEmpty &
         api_pumpRepairAck1.isEmpty &
         api_pumpRepairAck2.isEmpty &
         api_pumpRepairAck3.isEmpty &
         api_levelRepairAck.isEmpty &
         api_steamRepairAck.isEmpty)

  /** guarantee REQ_BCON_COMP_9
    *   Always send an OpMode
    * @param api_opMode outgoing event data port
    */
  @strictpure def compute_case_REQ_BCON_COMP_9(
      api_opMode: Option[BoilerControl.OpMode.Type]): B =
    (T) -->:
      (api_opMode.nonEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_1
    *   Water Meter Failure (No Repair): If the Water Meter was broken, and the repair message has not been sent. The Water Meter remains broken.
    * @param In_isWaterMeterFailing pre-state state variable
    * @param In_mode pre-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param api_levelRepair incoming event port
    * @param api_stop incoming event port
    * @param api_levelRepairAck outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_1(
      In_isWaterMeterFailing: Base_Types.Boolean,
      In_mode: BoilerControl.OpMode.Type,
      isWaterMeterFailing: Base_Types.Boolean,
      api_levelRepair: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_levelRepairAck: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       In_isWaterMeterFailing &
       !(api_levelRepair.nonEmpty)) -->:
      (isWaterMeterFailing & api_levelRepairAck.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_2
    *   Water Meter Failure (No Level): If the Water Meter provides no level event, The Water Meter is Broken.
    * @param In_mode pre-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param transmissionFailure post-state state variable
    * @param api_stop incoming event port
    * @param api_waterLevel incoming event data port
    * @param api_levelRepairAck outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_2(
      In_mode: BoilerControl.OpMode.Type,
      isWaterMeterFailing: Base_Types.Boolean,
      transmissionFailure: Base_Types.Boolean,
      api_stop: Option[art.Empty],
      api_waterLevel: Option[Base_Types.Float_32],
      api_levelRepairAck: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       !(api_waterLevel.nonEmpty)) -->:
      (isWaterMeterFailing & transmissionFailure &
         api_levelRepairAck.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_3
    *   Water Meter Failure (Invalid Level): If the Water Meter provides a level event, but it is less than or equal to 0, then the Water Meter is broken.
    * @param In_mode pre-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param api_stop incoming event port
    * @param api_waterLevel incoming event data port
    * @param api_levelRepairAck outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_3(
      In_mode: BoilerControl.OpMode.Type,
      isWaterMeterFailing: Base_Types.Boolean,
      api_stop: Option[art.Empty],
      api_waterLevel: Option[Base_Types.Float_32],
      api_levelRepairAck: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       api_waterLevel.nonEmpty &&
       api_waterLevel.get == 0.0f) -->:
      (isWaterMeterFailing & api_levelRepairAck.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_4
    *   Water Meter Repair: If the Water Meter was broken, but a repair event has been received, the Water Meter is not broken as long as there is a level event with a valid data payload.
    * @param In_isWaterMeterFailing pre-state state variable
    * @param In_mode pre-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param api_levelRepair incoming event port
    * @param api_stop incoming event port
    * @param api_waterLevel incoming event data port
    * @param api_levelRepairAck outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_4(
      In_isWaterMeterFailing: Base_Types.Boolean,
      In_mode: BoilerControl.OpMode.Type,
      isWaterMeterFailing: Base_Types.Boolean,
      api_levelRepair: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_waterLevel: Option[Base_Types.Float_32],
      api_levelRepairAck: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       api_levelRepair.nonEmpty &
       api_waterLevel.nonEmpty &&
       api_waterLevel.get > 0.0f) -->:
      (!isWaterMeterFailing &
         In_isWaterMeterFailing ->: api_levelRepairAck.nonEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_5
    *   Steam Meter Failure (No Repair): If the Steam Meter was broken, and the repair message has not been sent. The Steam Meter remains broken.
    * @param In_isSteamMeterFailing pre-state state variable
    * @param In_mode pre-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param api_steamRepair incoming event port
    * @param api_stop incoming event port
    * @param api_steamRepairAck outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_5(
      In_isSteamMeterFailing: Base_Types.Boolean,
      In_mode: BoilerControl.OpMode.Type,
      isSteamMeterFailing: Base_Types.Boolean,
      api_steamRepair: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_steamRepairAck: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       In_isSteamMeterFailing &
       !(api_steamRepair.nonEmpty)) -->:
      (isSteamMeterFailing & api_steamRepairAck.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_6
    *   Steam Meter Failure (No steamRate): If the Steam Meter provides no steamRate event, The Steam Meter is Broken.
    * @param In_mode pre-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param transmissionFailure post-state state variable
    * @param api_stop incoming event port
    * @param api_steamRate incoming event data port
    * @param api_steamRepairAck outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_6(
      In_mode: BoilerControl.OpMode.Type,
      isSteamMeterFailing: Base_Types.Boolean,
      transmissionFailure: Base_Types.Boolean,
      api_stop: Option[art.Empty],
      api_steamRate: Option[Base_Types.Float_32],
      api_steamRepairAck: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       !(api_steamRate.nonEmpty)) -->:
      (isSteamMeterFailing & transmissionFailure &
         api_steamRepairAck.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_7
    *   Steam Meter Failure (Invalid steamRate): If the Steam Meter provides a steamRate event, but it is less than 0, then the Steam Meter is broken.
    * @param In_mode pre-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param api_stop incoming event port
    * @param api_steamRate incoming event data port
    * @param api_steamRepairAck outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_7(
      In_mode: BoilerControl.OpMode.Type,
      isSteamMeterFailing: Base_Types.Boolean,
      api_stop: Option[art.Empty],
      api_steamRate: Option[Base_Types.Float_32],
      api_steamRepairAck: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       api_steamRate.nonEmpty &&
       api_steamRate.get < 0.0f) -->:
      (isSteamMeterFailing & api_steamRepairAck.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_8
    *   Steam Meter Repair: If the Steam Meter was broken, but a repair event has been received, the Steam Meter is not broken as long as there is a steamRate event with a valid data payload.
    * @param In_isSteamMeterFailing pre-state state variable
    * @param In_mode pre-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param api_steamRepair incoming event port
    * @param api_stop incoming event port
    * @param api_steamRate incoming event data port
    * @param api_steamRepairAck outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_8(
      In_isSteamMeterFailing: Base_Types.Boolean,
      In_mode: BoilerControl.OpMode.Type,
      isSteamMeterFailing: Base_Types.Boolean,
      api_steamRepair: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_steamRate: Option[Base_Types.Float_32],
      api_steamRepairAck: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       api_steamRepair.nonEmpty &&
       api_steamRate.nonEmpty &&
       api_steamRate.get >= 0.0f) -->:
      (!isSteamMeterFailing &
         In_isSteamMeterFailing ->: api_steamRepairAck.nonEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_9_Pump0
    *   Pump Failure (No Repair): If a given Pump was broken, and the repair message for that pump has not been sent. The given Pump remains broken.
    * @param In_isPump0Failing pre-state state variable
    * @param In_mode pre-state state variable
    * @param isPump0Failing post-state state variable
    * @param api_pumpRepair0 incoming event port
    * @param api_stop incoming event port
    * @param api_pumpRepairAck0 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_9_Pump0(
      In_isPump0Failing: Base_Types.Boolean,
      In_mode: BoilerControl.OpMode.Type,
      isPump0Failing: Base_Types.Boolean,
      api_pumpRepair0: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_pumpRepairAck0: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       In_isPump0Failing &
       !(api_pumpRepair0.nonEmpty)) -->:
      (isPump0Failing & api_pumpRepairAck0.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_9_Pump1
    *   Pump Failure (No Repair): If a given Pump was broken, and the repair message for that pump has not been sent. The given Pump remains broken.
    * @param In_isPump1Failing pre-state state variable
    * @param In_mode pre-state state variable
    * @param isPump1Failing post-state state variable
    * @param api_pumpRepair1 incoming event port
    * @param api_stop incoming event port
    * @param api_pumpRepairAck1 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_9_Pump1(
      In_isPump1Failing: Base_Types.Boolean,
      In_mode: BoilerControl.OpMode.Type,
      isPump1Failing: Base_Types.Boolean,
      api_pumpRepair1: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_pumpRepairAck1: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       In_isPump1Failing &
       !(api_pumpRepair1.nonEmpty)) -->:
      (isPump1Failing & api_pumpRepairAck1.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_9_Pump2
    *   Pump Failure (No Repair): If a given Pump was broken, and the repair message for that pump has not been sent. The given Pump remains broken.
    * @param In_isPump2Failing pre-state state variable
    * @param In_mode pre-state state variable
    * @param isPump2Failing post-state state variable
    * @param api_pumpRepair2 incoming event port
    * @param api_stop incoming event port
    * @param api_pumpRepairAck2 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_9_Pump2(
      In_isPump2Failing: Base_Types.Boolean,
      In_mode: BoilerControl.OpMode.Type,
      isPump2Failing: Base_Types.Boolean,
      api_pumpRepair2: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_pumpRepairAck2: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       In_isPump2Failing &
       !(api_pumpRepair2.nonEmpty)) -->:
      (isPump2Failing & api_pumpRepairAck2.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_9_Pump3
    *   Pump Failure (No Repair): If a given Pump was broken, and the repair message for that pump has not been sent. The given Pump remains broken.
    * @param In_isPump3Failing pre-state state variable
    * @param In_mode pre-state state variable
    * @param isPump3Failing post-state state variable
    * @param api_pumpRepair3 incoming event port
    * @param api_stop incoming event port
    * @param api_pumpRepairAck3 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_9_Pump3(
      In_isPump3Failing: Base_Types.Boolean,
      In_mode: BoilerControl.OpMode.Type,
      isPump3Failing: Base_Types.Boolean,
      api_pumpRepair3: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_pumpRepairAck3: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       In_isPump3Failing &
       !(api_pumpRepair3.nonEmpty)) -->:
      (isPump3Failing & api_pumpRepairAck3.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_10_Pump0
    *   Pump Failure (No Open, or No Flow): If a given Pump provides no open or flow event, The Pump is Broken.
    * @param In_mode pre-state state variable
    * @param isPump0Failing post-state state variable
    * @param api_stop incoming event port
    * @param api_pumpFlow0 incoming event data port
    * @param api_pumpOpen0 incoming event data port
    * @param api_pumpRepairAck0 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_10_Pump0(
      In_mode: BoilerControl.OpMode.Type,
      isPump0Failing: Base_Types.Boolean,
      api_stop: Option[art.Empty],
      api_pumpFlow0: Option[Base_Types.Boolean],
      api_pumpOpen0: Option[Base_Types.Boolean],
      api_pumpRepairAck0: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       (!(api_pumpOpen0.nonEmpty) | !(api_pumpFlow0.nonEmpty))) -->:
      (isPump0Failing & api_pumpRepairAck0.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_10_Pump1
    *   Pump Failure (No Open, or No Flow): If a given Pump provides no open or flow event, The Pump is Broken.
    * @param In_mode pre-state state variable
    * @param isPump1Failing post-state state variable
    * @param api_stop incoming event port
    * @param api_pumpFlow1 incoming event data port
    * @param api_pumpOpen1 incoming event data port
    * @param api_pumpRepairAck1 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_10_Pump1(
      In_mode: BoilerControl.OpMode.Type,
      isPump1Failing: Base_Types.Boolean,
      api_stop: Option[art.Empty],
      api_pumpFlow1: Option[Base_Types.Boolean],
      api_pumpOpen1: Option[Base_Types.Boolean],
      api_pumpRepairAck1: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       (!(api_pumpOpen1.nonEmpty) | !(api_pumpFlow1.nonEmpty))) -->:
      (isPump1Failing & api_pumpRepairAck1.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_10_Pump2
    *   Pump Failure (No Open, or No Flow): If a given Pump provides no open or flow event, The Pump is Broken.
    * @param In_mode pre-state state variable
    * @param isPump2Failing post-state state variable
    * @param api_stop incoming event port
    * @param api_pumpFlow2 incoming event data port
    * @param api_pumpOpen2 incoming event data port
    * @param api_pumpRepairAck2 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_10_Pump2(
      In_mode: BoilerControl.OpMode.Type,
      isPump2Failing: Base_Types.Boolean,
      api_stop: Option[art.Empty],
      api_pumpFlow2: Option[Base_Types.Boolean],
      api_pumpOpen2: Option[Base_Types.Boolean],
      api_pumpRepairAck2: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       (!(api_pumpOpen2.nonEmpty) | !(api_pumpFlow2.nonEmpty))) -->:
      (isPump2Failing & api_pumpRepairAck2.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_10_Pump3
    *   Pump Failure (No Open, or No Flow): If a given Pump provides no open or flow event, The Pump is Broken.
    * @param In_mode pre-state state variable
    * @param isPump3Failing post-state state variable
    * @param api_stop incoming event port
    * @param api_pumpFlow3 incoming event data port
    * @param api_pumpOpen3 incoming event data port
    * @param api_pumpRepairAck3 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_10_Pump3(
      In_mode: BoilerControl.OpMode.Type,
      isPump3Failing: Base_Types.Boolean,
      api_stop: Option[art.Empty],
      api_pumpFlow3: Option[Base_Types.Boolean],
      api_pumpOpen3: Option[Base_Types.Boolean],
      api_pumpRepairAck3: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       (!(api_pumpOpen3.nonEmpty) | !(api_pumpFlow3.nonEmpty))) -->:
      (isPump3Failing & api_pumpRepairAck3.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_11_Pump0
    *   Pump Failure (Invalid Level): If a given Pump provides an open and flow event, but they do not logically match (if open then flow or if !open then !flow), then the Pump is broken.
    * @param In_mode pre-state state variable
    * @param isPump0Failing post-state state variable
    * @param api_stop incoming event port
    * @param api_pumpFlow0 incoming event data port
    * @param api_pumpOpen0 incoming event data port
    * @param api_pumpRepairAck0 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_11_Pump0(
      In_mode: BoilerControl.OpMode.Type,
      isPump0Failing: Base_Types.Boolean,
      api_stop: Option[art.Empty],
      api_pumpFlow0: Option[Base_Types.Boolean],
      api_pumpOpen0: Option[Base_Types.Boolean],
      api_pumpRepairAck0: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       api_pumpOpen0.nonEmpty &&
       api_pumpFlow0.nonEmpty &&
       api_pumpOpen0.get != api_pumpFlow0.get) -->:
      (isPump0Failing & api_pumpRepairAck0.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_11_Pump1
    *   Pump Failure (Invalid Level): If a given Pump provides an open and flow event, but they do not logically match (if open then flow or if !open then !flow), then the Pump is broken.
    * @param In_mode pre-state state variable
    * @param isPump1Failing post-state state variable
    * @param api_stop incoming event port
    * @param api_pumpFlow1 incoming event data port
    * @param api_pumpOpen1 incoming event data port
    * @param api_pumpRepairAck1 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_11_Pump1(
      In_mode: BoilerControl.OpMode.Type,
      isPump1Failing: Base_Types.Boolean,
      api_stop: Option[art.Empty],
      api_pumpFlow1: Option[Base_Types.Boolean],
      api_pumpOpen1: Option[Base_Types.Boolean],
      api_pumpRepairAck1: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       api_pumpOpen1.nonEmpty &&
       api_pumpFlow1.nonEmpty &&
       api_pumpOpen1.get != api_pumpFlow1.get) -->:
      (isPump1Failing & api_pumpRepairAck1.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_11_Pump2
    *   Pump Failure (Invalid Level): If a given Pump provides an open and flow event, but they do not logically match (if open then flow or if !open then !flow), then the Pump is broken.
    * @param In_mode pre-state state variable
    * @param isPump2Failing post-state state variable
    * @param api_stop incoming event port
    * @param api_pumpFlow2 incoming event data port
    * @param api_pumpOpen2 incoming event data port
    * @param api_pumpRepairAck2 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_11_Pump2(
      In_mode: BoilerControl.OpMode.Type,
      isPump2Failing: Base_Types.Boolean,
      api_stop: Option[art.Empty],
      api_pumpFlow2: Option[Base_Types.Boolean],
      api_pumpOpen2: Option[Base_Types.Boolean],
      api_pumpRepairAck2: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       api_pumpOpen2.nonEmpty &&
       api_pumpFlow2.nonEmpty &&
       api_pumpOpen2.get != api_pumpFlow2.get) -->:
      (isPump2Failing & api_pumpRepairAck2.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_11_Pump3
    *   Pump Failure (Invalid Level): If a given Pump provides an open and flow event, but they do not logically match (if open then flow or if !open then !flow), then the Pump is broken.
    * @param In_mode pre-state state variable
    * @param isPump3Failing post-state state variable
    * @param api_stop incoming event port
    * @param api_pumpFlow3 incoming event data port
    * @param api_pumpOpen3 incoming event data port
    * @param api_pumpRepairAck3 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_11_Pump3(
      In_mode: BoilerControl.OpMode.Type,
      isPump3Failing: Base_Types.Boolean,
      api_stop: Option[art.Empty],
      api_pumpFlow3: Option[Base_Types.Boolean],
      api_pumpOpen3: Option[Base_Types.Boolean],
      api_pumpRepairAck3: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       api_pumpOpen3.nonEmpty &&
       api_pumpFlow3.nonEmpty &&
       api_pumpOpen3.get != api_pumpFlow3.get) -->:
      (isPump3Failing & api_pumpRepairAck3.isEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_12_Pump0
    *   Pump Repair: If a given Pump was broken, but a repair event for that pump has been received, the Pump is not broken as long as there is an open and flow event with a valid data payload.
    * @param In_mode pre-state state variable
    * @param isPump0Failing post-state state variable
    * @param api_pumpRepair0 incoming event port
    * @param api_stop incoming event port
    * @param api_pumpFlow0 incoming event data port
    * @param api_pumpOpen0 incoming event data port
    * @param api_pumpRepairAck0 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_12_Pump0(
      In_mode: BoilerControl.OpMode.Type,
      isPump0Failing: Base_Types.Boolean,
      api_pumpRepair0: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_pumpFlow0: Option[Base_Types.Boolean],
      api_pumpOpen0: Option[Base_Types.Boolean],
      api_pumpRepairAck0: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       api_pumpRepair0.nonEmpty &
       api_pumpOpen0.nonEmpty &&
       api_pumpFlow0.nonEmpty &&
       api_pumpOpen0.get == api_pumpFlow0.get) -->:
      (!isPump0Failing &
         isPump0Failing ->: api_pumpRepairAck0.nonEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_12_Pump1
    *   Pump Repair: If a given Pump was broken, but a repair event for that pump has been received, the Pump is not broken as long as there is an open and flow event with a valid data payload.
    * @param In_mode pre-state state variable
    * @param isPump1Failing post-state state variable
    * @param api_pumpRepair1 incoming event port
    * @param api_stop incoming event port
    * @param api_pumpFlow1 incoming event data port
    * @param api_pumpOpen1 incoming event data port
    * @param api_pumpRepairAck1 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_12_Pump1(
      In_mode: BoilerControl.OpMode.Type,
      isPump1Failing: Base_Types.Boolean,
      api_pumpRepair1: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_pumpFlow1: Option[Base_Types.Boolean],
      api_pumpOpen1: Option[Base_Types.Boolean],
      api_pumpRepairAck1: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       api_pumpRepair1.nonEmpty &
       api_pumpOpen1.nonEmpty &&
       api_pumpFlow1.nonEmpty &&
       api_pumpOpen1.get == api_pumpFlow1.get) -->:
      (!isPump1Failing &
         isPump1Failing ->: api_pumpRepairAck1.nonEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_12_Pump2
    *   Pump Repair: If a given Pump was broken, but a repair event for that pump has been received, the Pump is not broken as long as there is an open and flow event with a valid data payload.
    * @param In_mode pre-state state variable
    * @param isPump2Failing post-state state variable
    * @param api_pumpRepair2 incoming event port
    * @param api_stop incoming event port
    * @param api_pumpFlow2 incoming event data port
    * @param api_pumpOpen2 incoming event data port
    * @param api_pumpRepairAck2 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_12_Pump2(
      In_mode: BoilerControl.OpMode.Type,
      isPump2Failing: Base_Types.Boolean,
      api_pumpRepair2: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_pumpFlow2: Option[Base_Types.Boolean],
      api_pumpOpen2: Option[Base_Types.Boolean],
      api_pumpRepairAck2: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       api_pumpRepair2.nonEmpty &
       api_pumpOpen2.nonEmpty &&
       api_pumpFlow2.nonEmpty &&
       api_pumpOpen2.get == api_pumpFlow2.get) -->:
      (!isPump2Failing &
         isPump2Failing ->: api_pumpRepairAck2.nonEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_12_Pump3
    *   Pump Repair: If a given Pump was broken, but a repair event for that pump has been received, the Pump is not broken as long as there is an open and flow event with a valid data payload.
    * @param In_mode pre-state state variable
    * @param isPump3Failing post-state state variable
    * @param api_pumpRepair3 incoming event port
    * @param api_stop incoming event port
    * @param api_pumpFlow3 incoming event data port
    * @param api_pumpOpen3 incoming event data port
    * @param api_pumpRepairAck3 outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_12_Pump3(
      In_mode: BoilerControl.OpMode.Type,
      isPump3Failing: Base_Types.Boolean,
      api_pumpRepair3: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_pumpFlow3: Option[Base_Types.Boolean],
      api_pumpOpen3: Option[Base_Types.Boolean],
      api_pumpRepairAck3: Option[art.Empty]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty) &
       api_pumpRepair3.nonEmpty &
       api_pumpOpen3.nonEmpty &&
       api_pumpFlow3.nonEmpty &&
       api_pumpOpen3.get == api_pumpFlow3.get) -->:
      (!isPump3Failing &
         isPump3Failing ->: api_pumpRepairAck3.nonEmpty)

  /** guarantee REQ_BCON_COMP_CHECK_13
    *   Transmission Failure: If any of the following ports are empty, then the transmissionFailure state variable must be true: pumpOpen0, pumpOpen1, pumpOpen2, pumpOpen3, pumpFlow0, pumpFlow1, pumpFlow2, pumpFlow3, steamRate, waterLevel.
    * @param In_mode pre-state state variable
    * @param transmissionFailure post-state state variable
    * @param api_stop incoming event port
    * @param api_pumpFlow0 incoming event data port
    * @param api_pumpFlow1 incoming event data port
    * @param api_pumpFlow2 incoming event data port
    * @param api_pumpFlow3 incoming event data port
    * @param api_pumpOpen0 incoming event data port
    * @param api_pumpOpen1 incoming event data port
    * @param api_pumpOpen2 incoming event data port
    * @param api_pumpOpen3 incoming event data port
    * @param api_steamRate incoming event data port
    * @param api_waterLevel incoming event data port
    */
  @strictpure def compute_case_REQ_BCON_COMP_CHECK_13(
      In_mode: BoilerControl.OpMode.Type,
      transmissionFailure: Base_Types.Boolean,
      api_stop: Option[art.Empty],
      api_pumpFlow0: Option[Base_Types.Boolean],
      api_pumpFlow1: Option[Base_Types.Boolean],
      api_pumpFlow2: Option[Base_Types.Boolean],
      api_pumpFlow3: Option[Base_Types.Boolean],
      api_pumpOpen0: Option[Base_Types.Boolean],
      api_pumpOpen1: Option[Base_Types.Boolean],
      api_pumpOpen2: Option[Base_Types.Boolean],
      api_pumpOpen3: Option[Base_Types.Boolean],
      api_steamRate: Option[Base_Types.Float_32],
      api_waterLevel: Option[Base_Types.Float_32]): B =
    (In_mode != BoilerControl.OpMode.Stop &
       !(api_stop.nonEmpty)) -->:
      ((!(api_pumpFlow0.nonEmpty) | !(api_pumpOpen0.nonEmpty) |
          !(api_pumpFlow1.nonEmpty) |
          !(api_pumpOpen1.nonEmpty) |
          !(api_pumpFlow2.nonEmpty) |
          !(api_pumpOpen2.nonEmpty) |
          !(api_pumpFlow3.nonEmpty) |
          !(api_pumpOpen3.nonEmpty) |
          !(api_steamRate.nonEmpty) |
          !(api_waterLevel.nonEmpty)) ->: transmissionFailure)

  /** guarantee REQ_BCON_COMP_INITMODE_1
    *   If the boiler has not sent waiting yet, and the boiler control recieves the waiting event, hasBoilerSentWaiting is true.
    * @param In_hasBoilerSentWaiting pre-state state variable
    * @param In_mode pre-state state variable
    * @param hasBoilerSentWaiting post-state state variable
    * @param api_boilerWaiting incoming event port
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_INITMODE_1(
      In_hasBoilerSentWaiting: Base_Types.Boolean,
      In_mode: BoilerControl.OpMode.Type,
      hasBoilerSentWaiting: Base_Types.Boolean,
      api_boilerWaiting: Option[art.Empty],
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Init &
       !(api_stop.nonEmpty) &
       (!In_hasBoilerSentWaiting & api_boilerWaiting.nonEmpty)) -->:
      (hasBoilerSentWaiting)

  /** guarantee REQ_BCON_COMP_INITMODE_2
    *   If the steam meter is failing, or the steam rate recorded is not zero, then mode is stop.
    * @param In_mode pre-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param v_steamRate post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_INITMODE_2(
      In_mode: BoilerControl.OpMode.Type,
      isSteamMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      v_steamRate: Base_Types.Float_32,
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Init &
       !(api_stop.nonEmpty)) -->:
      ((v_steamRate != 0.0f |
          isSteamMeterFailing) ->: (mode == BoilerControl.OpMode.Stop))

  /** guarantee REQ_BCON_COMP_INITMODE_3
    *   If the water meter is failing, then mode is stop.
    * @param In_mode pre-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_INITMODE_3(
      In_mode: BoilerControl.OpMode.Type,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Init &
       !(api_stop.nonEmpty)) -->:
      (isWaterMeterFailing ->: (mode == BoilerControl.OpMode.Stop))

  /** guarantee REQ_BCON_COMP_INITMODE_4
    *   If the Boiler has sent waiting before, or we receive the event boilerWaiting, then if q > N2, the valve is opened, and the pumps are closed.
    * @param In_hasBoilerSentWaiting pre-state state variable
    * @param In_isSteamMeterFailing pre-state state variable
    * @param In_isWaterMeterFailing pre-state state variable
    * @param In_mode pre-state state variable
    * @param In_v_steamRate pre-state state variable
    * @param N2 post-state state variable
    * @param q post-state state variable
    * @param api_boilerWaiting incoming event port
    * @param api_stop incoming event port
    * @param api_valve outgoing event port
    * @param api_openPump0 outgoing event data port
    * @param api_openPump1 outgoing event data port
    * @param api_openPump2 outgoing event data port
    * @param api_openPump3 outgoing event data port
    */
  @strictpure def compute_case_REQ_BCON_COMP_INITMODE_4(
      In_hasBoilerSentWaiting: Base_Types.Boolean,
      In_isSteamMeterFailing: Base_Types.Boolean,
      In_isWaterMeterFailing: Base_Types.Boolean,
      In_mode: BoilerControl.OpMode.Type,
      In_v_steamRate: Base_Types.Float_32,
      N2: Base_Types.Float_32,
      q: Base_Types.Float_32,
      api_boilerWaiting: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_valve: Option[art.Empty],
      api_openPump0: Option[Base_Types.Boolean],
      api_openPump1: Option[Base_Types.Boolean],
      api_openPump2: Option[Base_Types.Boolean],
      api_openPump3: Option[Base_Types.Boolean]): B =
    (In_mode == BoilerControl.OpMode.Init &
       !(api_stop.nonEmpty) &
       (In_hasBoilerSentWaiting | api_boilerWaiting.nonEmpty) &
       !(In_v_steamRate != 0.0f |
         In_isSteamMeterFailing |
         In_isWaterMeterFailing)) -->:
      ((q > N2) ->: (api_valve.nonEmpty && api_openPump0.nonEmpty &&
          !(api_openPump0.get) &&
          api_openPump1.nonEmpty &&
          !(api_openPump1.get) &
          api_openPump2.nonEmpty &&
          !(api_openPump2.get) &&
          api_openPump3.nonEmpty &&
          !(api_openPump3.get)))

  /** guarantee REQ_BCON_COMP_INITMODE_5
    *   If the Boiler has sent waiting before, or we receive the event boilerWaiting, then if q < N1, the lowest id working pump is opened. If none can, mode to stop.
    * @param In_hasBoilerSentWaiting pre-state state variable
    * @param In_isSteamMeterFailing pre-state state variable
    * @param In_isWaterMeterFailing pre-state state variable
    * @param In_mode pre-state state variable
    * @param In_v_steamRate pre-state state variable
    * @param N1 post-state state variable
    * @param isPump0Failing post-state state variable
    * @param isPump1Failing post-state state variable
    * @param isPump2Failing post-state state variable
    * @param isPump3Failing post-state state variable
    * @param mode post-state state variable
    * @param q post-state state variable
    * @param api_boilerWaiting incoming event port
    * @param api_stop incoming event port
    * @param api_pumpOpen0 incoming event data port
    * @param api_pumpOpen1 incoming event data port
    * @param api_pumpOpen2 incoming event data port
    * @param api_pumpOpen3 incoming event data port
    */
  @strictpure def compute_case_REQ_BCON_COMP_INITMODE_5(
      In_hasBoilerSentWaiting: Base_Types.Boolean,
      In_isSteamMeterFailing: Base_Types.Boolean,
      In_isWaterMeterFailing: Base_Types.Boolean,
      In_mode: BoilerControl.OpMode.Type,
      In_v_steamRate: Base_Types.Float_32,
      N1: Base_Types.Float_32,
      isPump0Failing: Base_Types.Boolean,
      isPump1Failing: Base_Types.Boolean,
      isPump2Failing: Base_Types.Boolean,
      isPump3Failing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      q: Base_Types.Float_32,
      api_boilerWaiting: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_pumpOpen0: Option[Base_Types.Boolean],
      api_pumpOpen1: Option[Base_Types.Boolean],
      api_pumpOpen2: Option[Base_Types.Boolean],
      api_pumpOpen3: Option[Base_Types.Boolean]): B =
    (In_mode == BoilerControl.OpMode.Init &
       !(api_stop.nonEmpty) &
       (In_hasBoilerSentWaiting | api_boilerWaiting.nonEmpty) &
       !(In_v_steamRate != 0.0f |
         In_isSteamMeterFailing |
         In_isWaterMeterFailing)) -->:
      ((q < N1) ->: (!isPump0Failing && api_pumpOpen0.nonEmpty &&
          api_pumpOpen0.get == T |^
          isPump0Failing && !isPump1Failing &&
            api_pumpOpen1.nonEmpty &&
            api_pumpOpen1.get == T |^
          isPump0Failing && isPump1Failing &&
            !isPump2Failing &&
            api_pumpOpen2.nonEmpty &&
            api_pumpOpen2.get == T |^
          isPump0Failing && isPump1Failing &&
            isPump2Failing &&
            !isPump3Failing &&
            api_pumpOpen3.nonEmpty &&
            api_pumpOpen3.get == T |^
          isPump0Failing && isPump1Failing &&
            isPump2Failing &&
            isPump3Failing &&
            mode == BoilerControl.OpMode.Stop))

  /** guarantee REQ_BCON_COMP_INITMODE_6
    *   If the Boiler has sent waiting before, or we receive the event boilerWaiting, then if q >= N1 and q <= N2, then the ready event is sent. If all other parts are sending the ready event, mode is normal.
    * @param In_hasBoilerSentWaiting pre-state state variable
    * @param In_isSteamMeterFailing pre-state state variable
    * @param In_isWaterMeterFailing pre-state state variable
    * @param In_mode pre-state state variable
    * @param In_v_steamRate pre-state state variable
    * @param N1 post-state state variable
    * @param N2 post-state state variable
    * @param mode post-state state variable
    * @param q post-state state variable
    * @param api_boilerReady incoming event port
    * @param api_boilerWaiting incoming event port
    * @param api_pumpControlReady0 incoming event port
    * @param api_pumpControlReady1 incoming event port
    * @param api_pumpControlReady2 incoming event port
    * @param api_pumpControlReady3 incoming event port
    * @param api_steamMeterReady incoming event port
    * @param api_stop incoming event port
    * @param api_waterMeterReady incoming event port
    * @param api_ready outgoing event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_INITMODE_6(
      In_hasBoilerSentWaiting: Base_Types.Boolean,
      In_isSteamMeterFailing: Base_Types.Boolean,
      In_isWaterMeterFailing: Base_Types.Boolean,
      In_mode: BoilerControl.OpMode.Type,
      In_v_steamRate: Base_Types.Float_32,
      N1: Base_Types.Float_32,
      N2: Base_Types.Float_32,
      mode: BoilerControl.OpMode.Type,
      q: Base_Types.Float_32,
      api_boilerReady: Option[art.Empty],
      api_boilerWaiting: Option[art.Empty],
      api_pumpControlReady0: Option[art.Empty],
      api_pumpControlReady1: Option[art.Empty],
      api_pumpControlReady2: Option[art.Empty],
      api_pumpControlReady3: Option[art.Empty],
      api_steamMeterReady: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_waterMeterReady: Option[art.Empty],
      api_ready: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Init &
       !(api_stop.nonEmpty) &
       (In_hasBoilerSentWaiting | api_boilerWaiting.nonEmpty) &
       !(In_v_steamRate != 0.0f |
         In_isSteamMeterFailing |
         In_isWaterMeterFailing)) -->:
      ((q >= N1 &&
          q <= N2) ->: (api_ready.nonEmpty &
          (api_boilerReady.nonEmpty & api_steamMeterReady.nonEmpty &
            api_waterMeterReady.nonEmpty &
            api_pumpControlReady0.nonEmpty &
            api_pumpControlReady1.nonEmpty &
            api_pumpControlReady2.nonEmpty &
            api_pumpControlReady3.nonEmpty) ->: (mode == BoilerControl.OpMode.Norm)))

  /** guarantee REQ_BCON_COMP_NORMMODE_1
    *   NORMtoRESC: While in Normal mode, if the Water Meter fails, then mode to Rescue.
    * @param In_mode pre-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_NORMMODE_1(
      In_mode: BoilerControl.OpMode.Type,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Norm &
       !(api_stop.nonEmpty)) -->:
      (isWaterMeterFailing ->: (mode == BoilerControl.OpMode.Resc))

  /** guarantee REQ_BCON_COMP_NORMMODE_2
    *   NORMtoDEGR: While in Normal mode, if the Water Meter is working, but another element is failing, then mode to Degraded.
    * @param In_mode pre-state state variable
    * @param isPump0Failing post-state state variable
    * @param isPump1Failing post-state state variable
    * @param isPump2Failing post-state state variable
    * @param isPump3Failing post-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_NORMMODE_2(
      In_mode: BoilerControl.OpMode.Type,
      isPump0Failing: Base_Types.Boolean,
      isPump1Failing: Base_Types.Boolean,
      isPump2Failing: Base_Types.Boolean,
      isPump3Failing: Base_Types.Boolean,
      isSteamMeterFailing: Base_Types.Boolean,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Norm &
       !(api_stop.nonEmpty)) -->:
      ((!isWaterMeterFailing &&
          (isSteamMeterFailing | isPump0Failing |
            isPump1Failing |
            isPump2Failing |
            isPump3Failing)) ->: (mode == BoilerControl.OpMode.Degr))

  /** guarantee REQ_BCON_COMP_NORMMODE_3
    *   NORMtoSTOP: While in Normal mode, if all components are working, but qa1 or qa2 are not between M1 and M2, then mode will move to Stop.
    * @param In_mode pre-state state variable
    * @param M1 post-state state variable
    * @param M2 post-state state variable
    * @param isPump0Failing post-state state variable
    * @param isPump1Failing post-state state variable
    * @param isPump2Failing post-state state variable
    * @param isPump3Failing post-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_NORMMODE_3(
      In_mode: BoilerControl.OpMode.Type,
      M1: Base_Types.Float_32,
      M2: Base_Types.Float_32,
      isPump0Failing: Base_Types.Boolean,
      isPump1Failing: Base_Types.Boolean,
      isPump2Failing: Base_Types.Boolean,
      isPump3Failing: Base_Types.Boolean,
      isSteamMeterFailing: Base_Types.Boolean,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Norm &
       !(api_stop.nonEmpty)) -->:
      ((!(isWaterMeterFailing || isSteamMeterFailing ||
          isPump0Failing ||
          isPump1Failing ||
          isPump2Failing ||
          isPump3Failing) &&
          (qa1 <= M1 ||
            qa1 >= M2 ||
            qa2 <= M1 ||
            qa2 >= M2)) ->: (mode == BoilerControl.OpMode.Stop))

  /** guarantee REQ_BCON_COMP_NORMMODE_4
    *   NORMMAINTAIN: While in Normal mode, if all components are working, and qa1 or qa2 are between M1 and M2, then mode will remain Normal.
    * @param In_mode pre-state state variable
    * @param M1 post-state state variable
    * @param M2 post-state state variable
    * @param isPump0Failing post-state state variable
    * @param isPump1Failing post-state state variable
    * @param isPump2Failing post-state state variable
    * @param isPump3Failing post-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_NORMMODE_4(
      In_mode: BoilerControl.OpMode.Type,
      M1: Base_Types.Float_32,
      M2: Base_Types.Float_32,
      isPump0Failing: Base_Types.Boolean,
      isPump1Failing: Base_Types.Boolean,
      isPump2Failing: Base_Types.Boolean,
      isPump3Failing: Base_Types.Boolean,
      isSteamMeterFailing: Base_Types.Boolean,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Norm &
       !(api_stop.nonEmpty)) -->:
      ((!(isWaterMeterFailing || isSteamMeterFailing ||
          isPump0Failing ||
          isPump1Failing ||
          isPump2Failing ||
          isPump3Failing) && !(qa1 <= M1 ||
          qa1 >= M2 ||
          qa2 <= M1 ||
          qa2 >= M2)) ->: (mode == BoilerControl.OpMode.Norm))

  /** guarantee REQ_BCON_COMP_DEGRMODE_1
    *   DEGRtoRESC: While in Degraded mode, if the Water Meter Fails, then the mode shall be set to Rescue.
    * @param In_mode pre-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_DEGRMODE_1(
      In_mode: BoilerControl.OpMode.Type,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Degr &
       !(api_stop.nonEmpty)) -->:
      (isWaterMeterFailing ->: (mode == BoilerControl.OpMode.Resc))

  /** guarantee REQ_BCON_COMP_DEGRMODE_2
    *   DEGRtoSTOP: While in Degraded mode, if the Water Meter is not failing, but some other component is failing, and qc1 or qc2 is not between M1 and M2 exclusive, then the mode shall be set to Stop.
    * @param In_mode pre-state state variable
    * @param M1 post-state state variable
    * @param M2 post-state state variable
    * @param isPump0Failing post-state state variable
    * @param isPump1Failing post-state state variable
    * @param isPump2Failing post-state state variable
    * @param isPump3Failing post-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_DEGRMODE_2(
      In_mode: BoilerControl.OpMode.Type,
      M1: Base_Types.Float_32,
      M2: Base_Types.Float_32,
      isPump0Failing: Base_Types.Boolean,
      isPump1Failing: Base_Types.Boolean,
      isPump2Failing: Base_Types.Boolean,
      isPump3Failing: Base_Types.Boolean,
      isSteamMeterFailing: Base_Types.Boolean,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Degr &
       !(api_stop.nonEmpty)) -->:
      ((!isWaterMeterFailing &&
          (isSteamMeterFailing || isPump0Failing ||
            isPump1Failing ||
            isPump2Failing ||
            isPump3Failing) &&
          (qa1 <= M1 ||
            qa1 >= M2 ||
            qa2 <= M1 ||
            qa2 >= M2)) ->: (mode == BoilerControl.OpMode.Stop))

  /** guarantee REQ_BCON_COMP_DEGRMODE_3
    *   DEGRtoNORM: While in Degraded mode, if no component is failing, then mode is changed to Normal.
    * @param In_mode pre-state state variable
    * @param isPump0Failing post-state state variable
    * @param isPump1Failing post-state state variable
    * @param isPump2Failing post-state state variable
    * @param isPump3Failing post-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_DEGRMODE_3(
      In_mode: BoilerControl.OpMode.Type,
      isPump0Failing: Base_Types.Boolean,
      isPump1Failing: Base_Types.Boolean,
      isPump2Failing: Base_Types.Boolean,
      isPump3Failing: Base_Types.Boolean,
      isSteamMeterFailing: Base_Types.Boolean,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Degr &
       !(api_stop.nonEmpty)) -->:
      (!(isWaterMeterFailing || isSteamMeterFailing ||
          isPump0Failing ||
          isPump1Failing ||
          isPump2Failing ||
          isPump3Failing) ->: (mode == BoilerControl.OpMode.Norm))

  /** guarantee REQ_BCON_COMP_DEGRMODE_4
    *   DEGRMAINTAIN: While in Degraded mode, if Water Meter is not failing, but another component is, and qa1 and qa2 are between M1 and M2, then mode stays in Degraded, and the pumps should be updated.
    * @param In_mode pre-state state variable
    * @param M1 post-state state variable
    * @param M2 post-state state variable
    * @param isPump0Failing post-state state variable
    * @param isPump1Failing post-state state variable
    * @param isPump2Failing post-state state variable
    * @param isPump3Failing post-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param shouldUpdatePumps post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_DEGRMODE_4(
      In_mode: BoilerControl.OpMode.Type,
      M1: Base_Types.Float_32,
      M2: Base_Types.Float_32,
      isPump0Failing: Base_Types.Boolean,
      isPump1Failing: Base_Types.Boolean,
      isPump2Failing: Base_Types.Boolean,
      isPump3Failing: Base_Types.Boolean,
      isSteamMeterFailing: Base_Types.Boolean,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      shouldUpdatePumps: Base_Types.Boolean,
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Degr &
       !(api_stop.nonEmpty)) -->:
      ((!isWaterMeterFailing &&
          (isSteamMeterFailing || isPump0Failing ||
            isPump1Failing ||
            isPump2Failing ||
            isPump3Failing) &&
          !(qa1 <= M1 ||
            qa1 >= M2 ||
            qa2 <= M1 ||
            qa2 >= M2)) ->: (mode == BoilerControl.OpMode.Degr &&
          shouldUpdatePumps))

  /** guarantee REQ_BCON_COMP_RESCMODE_1
    *   RESCtoDEGR: While in Rescue Mode, if the Water Meter is operating properly, but another element has failed, then the mode should be changed to Degraded.
    * @param In_mode pre-state state variable
    * @param isPump0Failing post-state state variable
    * @param isPump1Failing post-state state variable
    * @param isPump2Failing post-state state variable
    * @param isPump3Failing post-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_RESCMODE_1(
      In_mode: BoilerControl.OpMode.Type,
      isPump0Failing: Base_Types.Boolean,
      isPump1Failing: Base_Types.Boolean,
      isPump2Failing: Base_Types.Boolean,
      isPump3Failing: Base_Types.Boolean,
      isSteamMeterFailing: Base_Types.Boolean,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Resc &
       !(api_stop.nonEmpty)) -->:
      ((!isWaterMeterFailing &&
          (isPump0Failing || isPump1Failing ||
            isPump2Failing ||
            isPump3Failing ||
            isSteamMeterFailing)) ->: (mode == BoilerControl.OpMode.Degr))

  /** guarantee REQ_BCON_COMP_RESCMODE_2
    *   RESCtoNORM: While in Rescue Mode, if there are no failures in any component, then mode moves to normal mode.
    * @param In_mode pre-state state variable
    * @param isPump0Failing post-state state variable
    * @param isPump1Failing post-state state variable
    * @param isPump2Failing post-state state variable
    * @param isPump3Failing post-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_RESCMODE_2(
      In_mode: BoilerControl.OpMode.Type,
      isPump0Failing: Base_Types.Boolean,
      isPump1Failing: Base_Types.Boolean,
      isPump2Failing: Base_Types.Boolean,
      isPump3Failing: Base_Types.Boolean,
      isSteamMeterFailing: Base_Types.Boolean,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Resc &
       !(api_stop.nonEmpty)) -->:
      (!(isWaterMeterFailing || isPump0Failing ||
          isPump1Failing ||
          isPump2Failing ||
          isPump3Failing ||
          isSteamMeterFailing) ->: (mode == BoilerControl.OpMode.Norm))

  /** guarantee REQ_BCON_COMP_RESCMODE_3
    *   RESCtoSTOP: While in Rescue Mode, if the Water Meter is failing, and either qc1 is not (M1 < qc1 < M2) or qc2 is not (M1 < qc2 < M2), then mode is Stop.
    * @param In_mode pre-state state variable
    * @param M1 post-state state variable
    * @param M2 post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param qc1 post-state state variable
    * @param qc2 post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_RESCMODE_3(
      In_mode: BoilerControl.OpMode.Type,
      M1: Base_Types.Float_32,
      M2: Base_Types.Float_32,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      qc1: Base_Types.Float_32,
      qc2: Base_Types.Float_32,
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Resc &
       !(api_stop.nonEmpty)) -->:
      ((isWaterMeterFailing &&
          (qc1 <= M1 ||
            qc1 >= M2 ||
            qc2 <= M1 ||
            qc2 >= M2)) ->: (mode == BoilerControl.OpMode.Stop))

  /** guarantee REQ_BCON_COMP_RESCMODE_4
    *   MAINTAINRESC: While in Rescue Mode, if the Water Meter is failing, and qc1 is (M1 < qc1 < M2) and qc2 is (M1 < qc2 < M2), then mode remains Resc.
    * @param In_mode pre-state state variable
    * @param M1 post-state state variable
    * @param M2 post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param qc1 post-state state variable
    * @param qc2 post-state state variable
    * @param api_stop incoming event port
    */
  @strictpure def compute_case_REQ_BCON_COMP_RESCMODE_4(
      In_mode: BoilerControl.OpMode.Type,
      M1: Base_Types.Float_32,
      M2: Base_Types.Float_32,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      qc1: Base_Types.Float_32,
      qc2: Base_Types.Float_32,
      api_stop: Option[art.Empty]): B =
    (In_mode == BoilerControl.OpMode.Resc &
       !(api_stop.nonEmpty)) -->:
      ((isWaterMeterFailing && !(qc1 <= M1 ||
          qc1 >= M2 ||
          qc2 <= M1 ||
          qc2 >= M2)) ->: (mode == BoilerControl.OpMode.Resc &&
          mode == In_mode))

  /** guarantee REQ_BCON_COMP_UPD_CASE_1
    *   Case 1 [509]: If qa1 and qa2 are less than N1, open pumps.
    * @param N1 post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param shouldUpdatePumps post-state state variable
    * @param api_openPump0 outgoing event data port
    * @param api_openPump1 outgoing event data port
    * @param api_openPump2 outgoing event data port
    * @param api_openPump3 outgoing event data port
    */
  @strictpure def compute_case_REQ_BCON_COMP_UPD_CASE_1(
      N1: Base_Types.Float_32,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      shouldUpdatePumps: Base_Types.Boolean,
      api_openPump0: Option[Base_Types.Boolean],
      api_openPump1: Option[Base_Types.Boolean],
      api_openPump2: Option[Base_Types.Boolean],
      api_openPump3: Option[Base_Types.Boolean]): B =
    (T) -->:
      ((shouldUpdatePumps &
          qa1 < N1 &
          qa2 < N1) ->: (api_openPump0.nonEmpty &&
          api_openPump0.get == T &&
          api_openPump1.nonEmpty &&
          api_openPump1.get == T &&
          api_openPump2.nonEmpty &&
          api_openPump2.get == T &&
          api_openPump3.nonEmpty &&
          api_openPump3.get == T))

  /** guarantee REQ_BCON_COMP_UPD_CASE_2
    *   Case 2 [509]: If qa1 is less than N1, and qa2 is less than N2, but qa2 is greater than N1, open pumps.
    * @param N1 post-state state variable
    * @param N2 post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param shouldUpdatePumps post-state state variable
    * @param api_openPump0 outgoing event data port
    * @param api_openPump1 outgoing event data port
    * @param api_openPump2 outgoing event data port
    * @param api_openPump3 outgoing event data port
    */
  @strictpure def compute_case_REQ_BCON_COMP_UPD_CASE_2(
      N1: Base_Types.Float_32,
      N2: Base_Types.Float_32,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      shouldUpdatePumps: Base_Types.Boolean,
      api_openPump0: Option[Base_Types.Boolean],
      api_openPump1: Option[Base_Types.Boolean],
      api_openPump2: Option[Base_Types.Boolean],
      api_openPump3: Option[Base_Types.Boolean]): B =
    (T) -->:
      ((shouldUpdatePumps &
          qa1 < N1 &
          qa2 < N2 &
          qa2 >= N1) ->: (api_openPump0.nonEmpty &&
          api_openPump0.get == T &&
          api_openPump1.nonEmpty &&
          api_openPump1.get == T &&
          api_openPump2.nonEmpty &&
          api_openPump2.get == T &&
          api_openPump3.nonEmpty &&
          api_openPump3.get == T))

  /** guarantee REQ_BCON_COMP_UPD_CASE_3
    *   Case 3 [509]: If qa1 is less than N1 and qa2 is greater than N2, then no call is sent the pumps.
    * @param N1 post-state state variable
    * @param N2 post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param shouldUpdatePumps post-state state variable
    * @param api_openPump0 outgoing event data port
    * @param api_openPump1 outgoing event data port
    * @param api_openPump2 outgoing event data port
    * @param api_openPump3 outgoing event data port
    */
  @strictpure def compute_case_REQ_BCON_COMP_UPD_CASE_3(
      N1: Base_Types.Float_32,
      N2: Base_Types.Float_32,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      shouldUpdatePumps: Base_Types.Boolean,
      api_openPump0: Option[Base_Types.Boolean],
      api_openPump1: Option[Base_Types.Boolean],
      api_openPump2: Option[Base_Types.Boolean],
      api_openPump3: Option[Base_Types.Boolean]): B =
    (T) -->:
      ((shouldUpdatePumps &
          qa1 < N1 &
          qa2 >= N2) ->: (!(api_openPump0.nonEmpty) && !(api_openPump1.nonEmpty) &&
          !(api_openPump2.nonEmpty) &&
          !(api_openPump3.nonEmpty)))

  /** guarantee REQ_BCON_COMP_UPD_CASE_4
    *   Case 4 [509]: If qa1 and qa2 are between N1 and N2, then no call is sent to the pumps.
    * @param N1 post-state state variable
    * @param N2 post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param shouldUpdatePumps post-state state variable
    * @param api_openPump0 outgoing event data port
    * @param api_openPump1 outgoing event data port
    * @param api_openPump2 outgoing event data port
    * @param api_openPump3 outgoing event data port
    */
  @strictpure def compute_case_REQ_BCON_COMP_UPD_CASE_4(
      N1: Base_Types.Float_32,
      N2: Base_Types.Float_32,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      shouldUpdatePumps: Base_Types.Boolean,
      api_openPump0: Option[Base_Types.Boolean],
      api_openPump1: Option[Base_Types.Boolean],
      api_openPump2: Option[Base_Types.Boolean],
      api_openPump3: Option[Base_Types.Boolean]): B =
    (T) -->:
      ((shouldUpdatePumps &
          qa1 >= N1 &
          qa1 < N2 &
          qa2 >= N1 &
          qa2 < N2) ->: (!(api_openPump0.nonEmpty) && !(api_openPump1.nonEmpty) &&
          !(api_openPump2.nonEmpty) &&
          !(api_openPump3.nonEmpty)))

  /** guarantee REQ_BCON_COMP_UPD_CASE_5
    *   Case 5 [509]: If qa1 is between N1 and N2 (less than N2), and qa2 is greater than or equal to N2.
    * @param N1 post-state state variable
    * @param N2 post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param shouldUpdatePumps post-state state variable
    * @param api_openPump0 outgoing event data port
    * @param api_openPump1 outgoing event data port
    * @param api_openPump2 outgoing event data port
    * @param api_openPump3 outgoing event data port
    */
  @strictpure def compute_case_REQ_BCON_COMP_UPD_CASE_5(
      N1: Base_Types.Float_32,
      N2: Base_Types.Float_32,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      shouldUpdatePumps: Base_Types.Boolean,
      api_openPump0: Option[Base_Types.Boolean],
      api_openPump1: Option[Base_Types.Boolean],
      api_openPump2: Option[Base_Types.Boolean],
      api_openPump3: Option[Base_Types.Boolean]): B =
    (T) -->:
      ((shouldUpdatePumps &
          qa1 >= N1 &
          qa1 < N2 &
          qa2 >= N2) ->: (api_openPump0.nonEmpty &&
          api_openPump0.get == F &&
          api_openPump1.nonEmpty &&
          api_openPump1.get == F &&
          api_openPump2.nonEmpty &&
          api_openPump2.get == F &&
          api_openPump3.nonEmpty &&
          api_openPump3.get == F))

  /** guarantee REQ_BCON_COMP_UPD_CASE_6
    *   Case 6 [509]: If qa1 is less than N1, and qa2 is less than N2, but qa2 is greater than N1, open pumps.
    * @param N2 post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param shouldUpdatePumps post-state state variable
    * @param api_openPump0 outgoing event data port
    * @param api_openPump1 outgoing event data port
    * @param api_openPump2 outgoing event data port
    * @param api_openPump3 outgoing event data port
    */
  @strictpure def compute_case_REQ_BCON_COMP_UPD_CASE_6(
      N2: Base_Types.Float_32,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      shouldUpdatePumps: Base_Types.Boolean,
      api_openPump0: Option[Base_Types.Boolean],
      api_openPump1: Option[Base_Types.Boolean],
      api_openPump2: Option[Base_Types.Boolean],
      api_openPump3: Option[Base_Types.Boolean]): B =
    (T) -->:
      ((shouldUpdatePumps &
          qa1 >= N2 &
          qa2 >= N2) ->: (api_openPump0.nonEmpty &&
          api_openPump0.get == F &&
          api_openPump1.nonEmpty &&
          api_openPump1.get == F &&
          api_openPump2.nonEmpty &&
          api_openPump2.get == F &&
          api_openPump3.nonEmpty &&
          api_openPump3.get == F))

  /** CEP-T-Case: Top-Level case contracts for control's compute entrypoint
    *
    * @param In_hasBoilerSentWaiting pre-state state variable
    * @param In_isPump0Failing pre-state state variable
    * @param In_isPump1Failing pre-state state variable
    * @param In_isPump2Failing pre-state state variable
    * @param In_isPump3Failing pre-state state variable
    * @param In_isSteamMeterFailing pre-state state variable
    * @param In_isWaterMeterFailing pre-state state variable
    * @param In_mode pre-state state variable
    * @param In_v_steamRate pre-state state variable
    * @param M1 post-state state variable
    * @param M2 post-state state variable
    * @param N1 post-state state variable
    * @param N2 post-state state variable
    * @param P post-state state variable
    * @param U1 post-state state variable
    * @param hasBoilerSentWaiting post-state state variable
    * @param isPump0Failing post-state state variable
    * @param isPump1Failing post-state state variable
    * @param isPump2Failing post-state state variable
    * @param isPump3Failing post-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param p0 post-state state variable
    * @param p1 post-state state variable
    * @param p2 post-state state variable
    * @param p3 post-state state variable
    * @param q post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param qc1 post-state state variable
    * @param qc2 post-state state variable
    * @param shouldUpdatePumps post-state state variable
    * @param transmissionFailure post-state state variable
    * @param v_steamRate post-state state variable
    * @param api_boilerReady incoming event port
    * @param api_boilerWaiting incoming event port
    * @param api_levelRepair incoming event port
    * @param api_pumpControlReady0 incoming event port
    * @param api_pumpControlReady1 incoming event port
    * @param api_pumpControlReady2 incoming event port
    * @param api_pumpControlReady3 incoming event port
    * @param api_pumpRepair0 incoming event port
    * @param api_pumpRepair1 incoming event port
    * @param api_pumpRepair2 incoming event port
    * @param api_pumpRepair3 incoming event port
    * @param api_steamMeterReady incoming event port
    * @param api_steamRepair incoming event port
    * @param api_stop incoming event port
    * @param api_waterMeterReady incoming event port
    * @param api_pumpFlow0 incoming event data port
    * @param api_pumpFlow1 incoming event data port
    * @param api_pumpFlow2 incoming event data port
    * @param api_pumpFlow3 incoming event data port
    * @param api_pumpOpen0 incoming event data port
    * @param api_pumpOpen1 incoming event data port
    * @param api_pumpOpen2 incoming event data port
    * @param api_pumpOpen3 incoming event data port
    * @param api_steamRate incoming event data port
    * @param api_waterLevel incoming event data port
    * @param api_levelFail outgoing event port
    * @param api_levelRepairAck outgoing event port
    * @param api_pumpControlFail0 outgoing event port
    * @param api_pumpControlFail1 outgoing event port
    * @param api_pumpControlFail2 outgoing event port
    * @param api_pumpControlFail3 outgoing event port
    * @param api_pumpFail0 outgoing event port
    * @param api_pumpFail1 outgoing event port
    * @param api_pumpFail2 outgoing event port
    * @param api_pumpFail3 outgoing event port
    * @param api_pumpRepairAck0 outgoing event port
    * @param api_pumpRepairAck1 outgoing event port
    * @param api_pumpRepairAck2 outgoing event port
    * @param api_pumpRepairAck3 outgoing event port
    * @param api_ready outgoing event port
    * @param api_steamFail outgoing event port
    * @param api_steamRepairAck outgoing event port
    * @param api_valve outgoing event port
    * @param api_opMode outgoing event data port
    * @param api_openPump0 outgoing event data port
    * @param api_openPump1 outgoing event data port
    * @param api_openPump2 outgoing event data port
    * @param api_openPump3 outgoing event data port
    */
  @strictpure def compute_CEP_T_Case (
      In_hasBoilerSentWaiting: Base_Types.Boolean,
      In_isPump0Failing: Base_Types.Boolean,
      In_isPump1Failing: Base_Types.Boolean,
      In_isPump2Failing: Base_Types.Boolean,
      In_isPump3Failing: Base_Types.Boolean,
      In_isSteamMeterFailing: Base_Types.Boolean,
      In_isWaterMeterFailing: Base_Types.Boolean,
      In_mode: BoilerControl.OpMode.Type,
      In_v_steamRate: Base_Types.Float_32,
      M1: Base_Types.Float_32,
      M2: Base_Types.Float_32,
      N1: Base_Types.Float_32,
      N2: Base_Types.Float_32,
      P: Base_Types.Float_32,
      U1: Base_Types.Float_32,
      hasBoilerSentWaiting: Base_Types.Boolean,
      isPump0Failing: Base_Types.Boolean,
      isPump1Failing: Base_Types.Boolean,
      isPump2Failing: Base_Types.Boolean,
      isPump3Failing: Base_Types.Boolean,
      isSteamMeterFailing: Base_Types.Boolean,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      p0: Base_Types.Float_32,
      p1: Base_Types.Float_32,
      p2: Base_Types.Float_32,
      p3: Base_Types.Float_32,
      q: Base_Types.Float_32,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      qc1: Base_Types.Float_32,
      qc2: Base_Types.Float_32,
      shouldUpdatePumps: Base_Types.Boolean,
      transmissionFailure: Base_Types.Boolean,
      v_steamRate: Base_Types.Float_32,
      api_boilerReady: Option[art.Empty],
      api_boilerWaiting: Option[art.Empty],
      api_levelRepair: Option[art.Empty],
      api_pumpControlReady0: Option[art.Empty],
      api_pumpControlReady1: Option[art.Empty],
      api_pumpControlReady2: Option[art.Empty],
      api_pumpControlReady3: Option[art.Empty],
      api_pumpRepair0: Option[art.Empty],
      api_pumpRepair1: Option[art.Empty],
      api_pumpRepair2: Option[art.Empty],
      api_pumpRepair3: Option[art.Empty],
      api_steamMeterReady: Option[art.Empty],
      api_steamRepair: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_waterMeterReady: Option[art.Empty],
      api_pumpFlow0: Option[Base_Types.Boolean],
      api_pumpFlow1: Option[Base_Types.Boolean],
      api_pumpFlow2: Option[Base_Types.Boolean],
      api_pumpFlow3: Option[Base_Types.Boolean],
      api_pumpOpen0: Option[Base_Types.Boolean],
      api_pumpOpen1: Option[Base_Types.Boolean],
      api_pumpOpen2: Option[Base_Types.Boolean],
      api_pumpOpen3: Option[Base_Types.Boolean],
      api_steamRate: Option[Base_Types.Float_32],
      api_waterLevel: Option[Base_Types.Float_32],
      api_levelFail: Option[art.Empty],
      api_levelRepairAck: Option[art.Empty],
      api_pumpControlFail0: Option[art.Empty],
      api_pumpControlFail1: Option[art.Empty],
      api_pumpControlFail2: Option[art.Empty],
      api_pumpControlFail3: Option[art.Empty],
      api_pumpFail0: Option[art.Empty],
      api_pumpFail1: Option[art.Empty],
      api_pumpFail2: Option[art.Empty],
      api_pumpFail3: Option[art.Empty],
      api_pumpRepairAck0: Option[art.Empty],
      api_pumpRepairAck1: Option[art.Empty],
      api_pumpRepairAck2: Option[art.Empty],
      api_pumpRepairAck3: Option[art.Empty],
      api_ready: Option[art.Empty],
      api_steamFail: Option[art.Empty],
      api_steamRepairAck: Option[art.Empty],
      api_valve: Option[art.Empty],
      api_opMode: Option[BoilerControl.OpMode.Type],
      api_openPump0: Option[Base_Types.Boolean],
      api_openPump1: Option[Base_Types.Boolean],
      api_openPump2: Option[Base_Types.Boolean],
      api_openPump3: Option[Base_Types.Boolean]): B =
    compute_case_REQ_BCON_COMP_1(mode, api_stop) &
    compute_case_REQ_BCON_COMP_2(In_mode, isPump0Failing, isPump1Failing, isPump2Failing, isPump3Failing, isSteamMeterFailing, isWaterMeterFailing, api_stop, api_levelFail, api_pumpFail0, api_pumpFail1, api_pumpFail2, api_pumpFail3, api_steamFail) &
    compute_case_REQ_BCON_COMP_3(In_mode, P, p0, p1, p2, p3, api_stop) &
    compute_case_REQ_BCON_COMP_4(In_mode, P, U1, q, qc1, qc2, v_steamRate, api_stop) &
    compute_case_REQ_BCON_COMP_5(In_mode, isWaterMeterFailing, qa1, qa2, qc1, qc2, api_stop) &
    compute_case_REQ_BCON_COMP_6(In_mode, isWaterMeterFailing, q, qa1, qa2, api_stop) &
    compute_case_REQ_BCON_COMP_7(mode, api_opMode) &
    compute_case_REQ_BCON_COMP_8(In_mode, api_levelFail, api_levelRepairAck, api_pumpControlFail0, api_pumpControlFail1, api_pumpControlFail2, api_pumpControlFail3, api_pumpFail0, api_pumpFail1, api_pumpFail2, api_pumpFail3, api_pumpRepairAck0, api_pumpRepairAck1, api_pumpRepairAck2, api_pumpRepairAck3, api_ready, api_steamFail, api_steamRepairAck, api_valve, api_opMode, api_openPump0, api_openPump1, api_openPump2, api_openPump3) &
    compute_case_REQ_BCON_COMP_9(api_opMode) &
    compute_case_REQ_BCON_COMP_CHECK_1(In_isWaterMeterFailing, In_mode, isWaterMeterFailing, api_levelRepair, api_stop, api_levelRepairAck) &
    compute_case_REQ_BCON_COMP_CHECK_2(In_mode, isWaterMeterFailing, transmissionFailure, api_stop, api_waterLevel, api_levelRepairAck) &
    compute_case_REQ_BCON_COMP_CHECK_3(In_mode, isWaterMeterFailing, api_stop, api_waterLevel, api_levelRepairAck) &
    compute_case_REQ_BCON_COMP_CHECK_4(In_isWaterMeterFailing, In_mode, isWaterMeterFailing, api_levelRepair, api_stop, api_waterLevel, api_levelRepairAck) &
    compute_case_REQ_BCON_COMP_CHECK_5(In_isSteamMeterFailing, In_mode, isSteamMeterFailing, api_steamRepair, api_stop, api_steamRepairAck) &
    compute_case_REQ_BCON_COMP_CHECK_6(In_mode, isSteamMeterFailing, transmissionFailure, api_stop, api_steamRate, api_steamRepairAck) &
    compute_case_REQ_BCON_COMP_CHECK_7(In_mode, isSteamMeterFailing, api_stop, api_steamRate, api_steamRepairAck) &
    compute_case_REQ_BCON_COMP_CHECK_8(In_isSteamMeterFailing, In_mode, isSteamMeterFailing, api_steamRepair, api_stop, api_steamRate, api_steamRepairAck) &
    compute_case_REQ_BCON_COMP_CHECK_9_Pump0(In_isPump0Failing, In_mode, isPump0Failing, api_pumpRepair0, api_stop, api_pumpRepairAck0) &
    compute_case_REQ_BCON_COMP_CHECK_9_Pump1(In_isPump1Failing, In_mode, isPump1Failing, api_pumpRepair1, api_stop, api_pumpRepairAck1) &
    compute_case_REQ_BCON_COMP_CHECK_9_Pump2(In_isPump2Failing, In_mode, isPump2Failing, api_pumpRepair2, api_stop, api_pumpRepairAck2) &
    compute_case_REQ_BCON_COMP_CHECK_9_Pump3(In_isPump3Failing, In_mode, isPump3Failing, api_pumpRepair3, api_stop, api_pumpRepairAck3) &
    compute_case_REQ_BCON_COMP_CHECK_10_Pump0(In_mode, isPump0Failing, api_stop, api_pumpFlow0, api_pumpOpen0, api_pumpRepairAck0) &
    compute_case_REQ_BCON_COMP_CHECK_10_Pump1(In_mode, isPump1Failing, api_stop, api_pumpFlow1, api_pumpOpen1, api_pumpRepairAck1) &
    compute_case_REQ_BCON_COMP_CHECK_10_Pump2(In_mode, isPump2Failing, api_stop, api_pumpFlow2, api_pumpOpen2, api_pumpRepairAck2) &
    compute_case_REQ_BCON_COMP_CHECK_10_Pump3(In_mode, isPump3Failing, api_stop, api_pumpFlow3, api_pumpOpen3, api_pumpRepairAck3) &
    compute_case_REQ_BCON_COMP_CHECK_11_Pump0(In_mode, isPump0Failing, api_stop, api_pumpFlow0, api_pumpOpen0, api_pumpRepairAck0) &
    compute_case_REQ_BCON_COMP_CHECK_11_Pump1(In_mode, isPump1Failing, api_stop, api_pumpFlow1, api_pumpOpen1, api_pumpRepairAck1) &
    compute_case_REQ_BCON_COMP_CHECK_11_Pump2(In_mode, isPump2Failing, api_stop, api_pumpFlow2, api_pumpOpen2, api_pumpRepairAck2) &
    compute_case_REQ_BCON_COMP_CHECK_11_Pump3(In_mode, isPump3Failing, api_stop, api_pumpFlow3, api_pumpOpen3, api_pumpRepairAck3) &
    compute_case_REQ_BCON_COMP_CHECK_12_Pump0(In_mode, isPump0Failing, api_pumpRepair0, api_stop, api_pumpFlow0, api_pumpOpen0, api_pumpRepairAck0) &
    compute_case_REQ_BCON_COMP_CHECK_12_Pump1(In_mode, isPump1Failing, api_pumpRepair1, api_stop, api_pumpFlow1, api_pumpOpen1, api_pumpRepairAck1) &
    compute_case_REQ_BCON_COMP_CHECK_12_Pump2(In_mode, isPump2Failing, api_pumpRepair2, api_stop, api_pumpFlow2, api_pumpOpen2, api_pumpRepairAck2) &
    compute_case_REQ_BCON_COMP_CHECK_12_Pump3(In_mode, isPump3Failing, api_pumpRepair3, api_stop, api_pumpFlow3, api_pumpOpen3, api_pumpRepairAck3) &
    compute_case_REQ_BCON_COMP_CHECK_13(In_mode, transmissionFailure, api_stop, api_pumpFlow0, api_pumpFlow1, api_pumpFlow2, api_pumpFlow3, api_pumpOpen0, api_pumpOpen1, api_pumpOpen2, api_pumpOpen3, api_steamRate, api_waterLevel) &
    compute_case_REQ_BCON_COMP_INITMODE_1(In_hasBoilerSentWaiting, In_mode, hasBoilerSentWaiting, api_boilerWaiting, api_stop) &
    compute_case_REQ_BCON_COMP_INITMODE_2(In_mode, isSteamMeterFailing, mode, v_steamRate, api_stop) &
    compute_case_REQ_BCON_COMP_INITMODE_3(In_mode, isWaterMeterFailing, mode, api_stop) &
    compute_case_REQ_BCON_COMP_INITMODE_4(In_hasBoilerSentWaiting, In_isSteamMeterFailing, In_isWaterMeterFailing, In_mode, In_v_steamRate, N2, q, api_boilerWaiting, api_stop, api_valve, api_openPump0, api_openPump1, api_openPump2, api_openPump3) &
    compute_case_REQ_BCON_COMP_INITMODE_5(In_hasBoilerSentWaiting, In_isSteamMeterFailing, In_isWaterMeterFailing, In_mode, In_v_steamRate, N1, isPump0Failing, isPump1Failing, isPump2Failing, isPump3Failing, mode, q, api_boilerWaiting, api_stop, api_pumpOpen0, api_pumpOpen1, api_pumpOpen2, api_pumpOpen3) &
    compute_case_REQ_BCON_COMP_INITMODE_6(In_hasBoilerSentWaiting, In_isSteamMeterFailing, In_isWaterMeterFailing, In_mode, In_v_steamRate, N1, N2, mode, q, api_boilerReady, api_boilerWaiting, api_pumpControlReady0, api_pumpControlReady1, api_pumpControlReady2, api_pumpControlReady3, api_steamMeterReady, api_stop, api_waterMeterReady, api_ready) &
    compute_case_REQ_BCON_COMP_NORMMODE_1(In_mode, isWaterMeterFailing, mode, api_stop) &
    compute_case_REQ_BCON_COMP_NORMMODE_2(In_mode, isPump0Failing, isPump1Failing, isPump2Failing, isPump3Failing, isSteamMeterFailing, isWaterMeterFailing, mode, api_stop) &
    compute_case_REQ_BCON_COMP_NORMMODE_3(In_mode, M1, M2, isPump0Failing, isPump1Failing, isPump2Failing, isPump3Failing, isSteamMeterFailing, isWaterMeterFailing, mode, qa1, qa2, api_stop) &
    compute_case_REQ_BCON_COMP_NORMMODE_4(In_mode, M1, M2, isPump0Failing, isPump1Failing, isPump2Failing, isPump3Failing, isSteamMeterFailing, isWaterMeterFailing, mode, qa1, qa2, api_stop) &
    compute_case_REQ_BCON_COMP_DEGRMODE_1(In_mode, isWaterMeterFailing, mode, api_stop) &
    compute_case_REQ_BCON_COMP_DEGRMODE_2(In_mode, M1, M2, isPump0Failing, isPump1Failing, isPump2Failing, isPump3Failing, isSteamMeterFailing, isWaterMeterFailing, mode, qa1, qa2, api_stop) &
    compute_case_REQ_BCON_COMP_DEGRMODE_3(In_mode, isPump0Failing, isPump1Failing, isPump2Failing, isPump3Failing, isSteamMeterFailing, isWaterMeterFailing, mode, api_stop) &
    compute_case_REQ_BCON_COMP_DEGRMODE_4(In_mode, M1, M2, isPump0Failing, isPump1Failing, isPump2Failing, isPump3Failing, isSteamMeterFailing, isWaterMeterFailing, mode, qa1, qa2, shouldUpdatePumps, api_stop) &
    compute_case_REQ_BCON_COMP_RESCMODE_1(In_mode, isPump0Failing, isPump1Failing, isPump2Failing, isPump3Failing, isSteamMeterFailing, isWaterMeterFailing, mode, api_stop) &
    compute_case_REQ_BCON_COMP_RESCMODE_2(In_mode, isPump0Failing, isPump1Failing, isPump2Failing, isPump3Failing, isSteamMeterFailing, isWaterMeterFailing, mode, api_stop) &
    compute_case_REQ_BCON_COMP_RESCMODE_3(In_mode, M1, M2, isWaterMeterFailing, mode, qc1, qc2, api_stop) &
    compute_case_REQ_BCON_COMP_RESCMODE_4(In_mode, M1, M2, isWaterMeterFailing, mode, qc1, qc2, api_stop) &
    compute_case_REQ_BCON_COMP_UPD_CASE_1(N1, qa1, qa2, shouldUpdatePumps, api_openPump0, api_openPump1, api_openPump2, api_openPump3) &
    compute_case_REQ_BCON_COMP_UPD_CASE_2(N1, N2, qa1, qa2, shouldUpdatePumps, api_openPump0, api_openPump1, api_openPump2, api_openPump3) &
    compute_case_REQ_BCON_COMP_UPD_CASE_3(N1, N2, qa1, qa2, shouldUpdatePumps, api_openPump0, api_openPump1, api_openPump2, api_openPump3) &
    compute_case_REQ_BCON_COMP_UPD_CASE_4(N1, N2, qa1, qa2, shouldUpdatePumps, api_openPump0, api_openPump1, api_openPump2, api_openPump3) &
    compute_case_REQ_BCON_COMP_UPD_CASE_5(N1, N2, qa1, qa2, shouldUpdatePumps, api_openPump0, api_openPump1, api_openPump2, api_openPump3) &
    compute_case_REQ_BCON_COMP_UPD_CASE_6(N2, qa1, qa2, shouldUpdatePumps, api_openPump0, api_openPump1, api_openPump2, api_openPump3)

  /** CEP-Post: Compute Entrypoint Post-Condition for control
    *
    * @param In_C pre-state state variable
    * @param In_M1 pre-state state variable
    * @param In_M2 pre-state state variable
    * @param In_N1 pre-state state variable
    * @param In_N2 pre-state state variable
    * @param In_P pre-state state variable
    * @param In_U1 pre-state state variable
    * @param In_U2 pre-state state variable
    * @param In_W pre-state state variable
    * @param In_hasBoilerSentWaiting pre-state state variable
    * @param In_isPump0Failing pre-state state variable
    * @param In_isPump1Failing pre-state state variable
    * @param In_isPump2Failing pre-state state variable
    * @param In_isPump3Failing pre-state state variable
    * @param In_isSteamMeterFailing pre-state state variable
    * @param In_isWaterMeterFailing pre-state state variable
    * @param In_mode pre-state state variable
    * @param In_p0 pre-state state variable
    * @param In_p1 pre-state state variable
    * @param In_p2 pre-state state variable
    * @param In_p3 pre-state state variable
    * @param In_q pre-state state variable
    * @param In_qa1 pre-state state variable
    * @param In_qa2 pre-state state variable
    * @param In_qc1 pre-state state variable
    * @param In_qc2 pre-state state variable
    * @param In_shouldUpdatePumps pre-state state variable
    * @param In_transmissionFailure pre-state state variable
    * @param In_v_steamRate pre-state state variable
    * @param C post-state state variable
    * @param M1 post-state state variable
    * @param M2 post-state state variable
    * @param N1 post-state state variable
    * @param N2 post-state state variable
    * @param P post-state state variable
    * @param U1 post-state state variable
    * @param U2 post-state state variable
    * @param W post-state state variable
    * @param hasBoilerSentWaiting post-state state variable
    * @param isPump0Failing post-state state variable
    * @param isPump1Failing post-state state variable
    * @param isPump2Failing post-state state variable
    * @param isPump3Failing post-state state variable
    * @param isSteamMeterFailing post-state state variable
    * @param isWaterMeterFailing post-state state variable
    * @param mode post-state state variable
    * @param p0 post-state state variable
    * @param p1 post-state state variable
    * @param p2 post-state state variable
    * @param p3 post-state state variable
    * @param q post-state state variable
    * @param qa1 post-state state variable
    * @param qa2 post-state state variable
    * @param qc1 post-state state variable
    * @param qc2 post-state state variable
    * @param shouldUpdatePumps post-state state variable
    * @param transmissionFailure post-state state variable
    * @param v_steamRate post-state state variable
    * @param api_boilerReady incoming event port
    * @param api_boilerWaiting incoming event port
    * @param api_levelRepair incoming event port
    * @param api_pumpControlReady0 incoming event port
    * @param api_pumpControlReady1 incoming event port
    * @param api_pumpControlReady2 incoming event port
    * @param api_pumpControlReady3 incoming event port
    * @param api_pumpRepair0 incoming event port
    * @param api_pumpRepair1 incoming event port
    * @param api_pumpRepair2 incoming event port
    * @param api_pumpRepair3 incoming event port
    * @param api_steamMeterReady incoming event port
    * @param api_steamRepair incoming event port
    * @param api_stop incoming event port
    * @param api_waterMeterReady incoming event port
    * @param api_pumpFlow0 incoming event data port
    * @param api_pumpFlow1 incoming event data port
    * @param api_pumpFlow2 incoming event data port
    * @param api_pumpFlow3 incoming event data port
    * @param api_pumpOpen0 incoming event data port
    * @param api_pumpOpen1 incoming event data port
    * @param api_pumpOpen2 incoming event data port
    * @param api_pumpOpen3 incoming event data port
    * @param api_steamRate incoming event data port
    * @param api_waterLevel incoming event data port
    * @param api_levelFail outgoing event port
    * @param api_levelRepairAck outgoing event port
    * @param api_pumpControlFail0 outgoing event port
    * @param api_pumpControlFail1 outgoing event port
    * @param api_pumpControlFail2 outgoing event port
    * @param api_pumpControlFail3 outgoing event port
    * @param api_pumpControlRepairAck0 outgoing event port
    * @param api_pumpControlRepairAck1 outgoing event port
    * @param api_pumpControlRepairAck2 outgoing event port
    * @param api_pumpControlRepairAck3 outgoing event port
    * @param api_pumpFail0 outgoing event port
    * @param api_pumpFail1 outgoing event port
    * @param api_pumpFail2 outgoing event port
    * @param api_pumpFail3 outgoing event port
    * @param api_pumpRepairAck0 outgoing event port
    * @param api_pumpRepairAck1 outgoing event port
    * @param api_pumpRepairAck2 outgoing event port
    * @param api_pumpRepairAck3 outgoing event port
    * @param api_ready outgoing event port
    * @param api_steamFail outgoing event port
    * @param api_steamRepairAck outgoing event port
    * @param api_valve outgoing event port
    * @param api_opMode outgoing event data port
    * @param api_openPump0 outgoing event data port
    * @param api_openPump1 outgoing event data port
    * @param api_openPump2 outgoing event data port
    * @param api_openPump3 outgoing event data port
    */
  @strictpure def compute_CEP_Post (
      In_C: Base_Types.Float_32,
      In_M1: Base_Types.Float_32,
      In_M2: Base_Types.Float_32,
      In_N1: Base_Types.Float_32,
      In_N2: Base_Types.Float_32,
      In_P: Base_Types.Float_32,
      In_U1: Base_Types.Float_32,
      In_U2: Base_Types.Float_32,
      In_W: Base_Types.Float_32,
      In_hasBoilerSentWaiting: Base_Types.Boolean,
      In_isPump0Failing: Base_Types.Boolean,
      In_isPump1Failing: Base_Types.Boolean,
      In_isPump2Failing: Base_Types.Boolean,
      In_isPump3Failing: Base_Types.Boolean,
      In_isSteamMeterFailing: Base_Types.Boolean,
      In_isWaterMeterFailing: Base_Types.Boolean,
      In_mode: BoilerControl.OpMode.Type,
      In_p0: Base_Types.Float_32,
      In_p1: Base_Types.Float_32,
      In_p2: Base_Types.Float_32,
      In_p3: Base_Types.Float_32,
      In_q: Base_Types.Float_32,
      In_qa1: Base_Types.Float_32,
      In_qa2: Base_Types.Float_32,
      In_qc1: Base_Types.Float_32,
      In_qc2: Base_Types.Float_32,
      In_shouldUpdatePumps: Base_Types.Boolean,
      In_transmissionFailure: Base_Types.Boolean,
      In_v_steamRate: Base_Types.Float_32,
      C: Base_Types.Float_32,
      M1: Base_Types.Float_32,
      M2: Base_Types.Float_32,
      N1: Base_Types.Float_32,
      N2: Base_Types.Float_32,
      P: Base_Types.Float_32,
      U1: Base_Types.Float_32,
      U2: Base_Types.Float_32,
      W: Base_Types.Float_32,
      hasBoilerSentWaiting: Base_Types.Boolean,
      isPump0Failing: Base_Types.Boolean,
      isPump1Failing: Base_Types.Boolean,
      isPump2Failing: Base_Types.Boolean,
      isPump3Failing: Base_Types.Boolean,
      isSteamMeterFailing: Base_Types.Boolean,
      isWaterMeterFailing: Base_Types.Boolean,
      mode: BoilerControl.OpMode.Type,
      p0: Base_Types.Float_32,
      p1: Base_Types.Float_32,
      p2: Base_Types.Float_32,
      p3: Base_Types.Float_32,
      q: Base_Types.Float_32,
      qa1: Base_Types.Float_32,
      qa2: Base_Types.Float_32,
      qc1: Base_Types.Float_32,
      qc2: Base_Types.Float_32,
      shouldUpdatePumps: Base_Types.Boolean,
      transmissionFailure: Base_Types.Boolean,
      v_steamRate: Base_Types.Float_32,
      api_boilerReady: Option[art.Empty],
      api_boilerWaiting: Option[art.Empty],
      api_levelRepair: Option[art.Empty],
      api_pumpControlReady0: Option[art.Empty],
      api_pumpControlReady1: Option[art.Empty],
      api_pumpControlReady2: Option[art.Empty],
      api_pumpControlReady3: Option[art.Empty],
      api_pumpRepair0: Option[art.Empty],
      api_pumpRepair1: Option[art.Empty],
      api_pumpRepair2: Option[art.Empty],
      api_pumpRepair3: Option[art.Empty],
      api_steamMeterReady: Option[art.Empty],
      api_steamRepair: Option[art.Empty],
      api_stop: Option[art.Empty],
      api_waterMeterReady: Option[art.Empty],
      api_pumpFlow0: Option[Base_Types.Boolean],
      api_pumpFlow1: Option[Base_Types.Boolean],
      api_pumpFlow2: Option[Base_Types.Boolean],
      api_pumpFlow3: Option[Base_Types.Boolean],
      api_pumpOpen0: Option[Base_Types.Boolean],
      api_pumpOpen1: Option[Base_Types.Boolean],
      api_pumpOpen2: Option[Base_Types.Boolean],
      api_pumpOpen3: Option[Base_Types.Boolean],
      api_steamRate: Option[Base_Types.Float_32],
      api_waterLevel: Option[Base_Types.Float_32],
      api_levelFail: Option[art.Empty],
      api_levelRepairAck: Option[art.Empty],
      api_pumpControlFail0: Option[art.Empty],
      api_pumpControlFail1: Option[art.Empty],
      api_pumpControlFail2: Option[art.Empty],
      api_pumpControlFail3: Option[art.Empty],
      api_pumpControlRepairAck0: Option[art.Empty],
      api_pumpControlRepairAck1: Option[art.Empty],
      api_pumpControlRepairAck2: Option[art.Empty],
      api_pumpControlRepairAck3: Option[art.Empty],
      api_pumpFail0: Option[art.Empty],
      api_pumpFail1: Option[art.Empty],
      api_pumpFail2: Option[art.Empty],
      api_pumpFail3: Option[art.Empty],
      api_pumpRepairAck0: Option[art.Empty],
      api_pumpRepairAck1: Option[art.Empty],
      api_pumpRepairAck2: Option[art.Empty],
      api_pumpRepairAck3: Option[art.Empty],
      api_ready: Option[art.Empty],
      api_steamFail: Option[art.Empty],
      api_steamRepairAck: Option[art.Empty],
      api_valve: Option[art.Empty],
      api_opMode: Option[BoilerControl.OpMode.Type],
      api_openPump0: Option[Base_Types.Boolean],
      api_openPump1: Option[Base_Types.Boolean],
      api_openPump2: Option[Base_Types.Boolean],
      api_openPump3: Option[Base_Types.Boolean]): B =
    (// CEP-T-Case: case clauses of control's compute entrypoint
     compute_CEP_T_Case (In_hasBoilerSentWaiting, In_isPump0Failing, In_isPump1Failing, In_isPump2Failing, In_isPump3Failing, In_isSteamMeterFailing, In_isWaterMeterFailing, In_mode, In_v_steamRate, M1, M2, N1, N2, P, U1, hasBoilerSentWaiting, isPump0Failing, isPump1Failing, isPump2Failing, isPump3Failing, isSteamMeterFailing, isWaterMeterFailing, mode, p0, p1, p2, p3, q, qa1, qa2, qc1, qc2, shouldUpdatePumps, transmissionFailure, v_steamRate, api_boilerReady, api_boilerWaiting, api_levelRepair, api_pumpControlReady0, api_pumpControlReady1, api_pumpControlReady2, api_pumpControlReady3, api_pumpRepair0, api_pumpRepair1, api_pumpRepair2, api_pumpRepair3, api_steamMeterReady, api_steamRepair, api_stop, api_waterMeterReady, api_pumpFlow0, api_pumpFlow1, api_pumpFlow2, api_pumpFlow3, api_pumpOpen0, api_pumpOpen1, api_pumpOpen2, api_pumpOpen3, api_steamRate, api_waterLevel, api_levelFail, api_levelRepairAck, api_pumpControlFail0, api_pumpControlFail1, api_pumpControlFail2, api_pumpControlFail3, api_pumpFail0, api_pumpFail1, api_pumpFail2, api_pumpFail3, api_pumpRepairAck0, api_pumpRepairAck1, api_pumpRepairAck2, api_pumpRepairAck3, api_ready, api_steamFail, api_steamRepairAck, api_valve, api_opMode, api_openPump0, api_openPump1, api_openPump2, api_openPump3))

  /** CEP-Post: Compute Entrypoint Post-Condition for control via containers
    *
    * @param pre Container holding the values of incoming ports and the pre-state values of state variables
    * @param post Container holding the values of outgoing ports and the post-state values of state variables
    */
  @strictpure def compute_CEP_Post_Container(
      pre: BoilerControl_i_bcproc_control_PreState_Container_PS,
      post: BoilerControl_i_bcproc_control_PostState_Container_PS): B =
    compute_CEP_Post(
      In_C = pre.In_C,
      In_M1 = pre.In_M1,
      In_M2 = pre.In_M2,
      In_N1 = pre.In_N1,
      In_N2 = pre.In_N2,
      In_P = pre.In_P,
      In_U1 = pre.In_U1,
      In_U2 = pre.In_U2,
      In_W = pre.In_W,
      In_hasBoilerSentWaiting = pre.In_hasBoilerSentWaiting,
      In_isPump0Failing = pre.In_isPump0Failing,
      In_isPump1Failing = pre.In_isPump1Failing,
      In_isPump2Failing = pre.In_isPump2Failing,
      In_isPump3Failing = pre.In_isPump3Failing,
      In_isSteamMeterFailing = pre.In_isSteamMeterFailing,
      In_isWaterMeterFailing = pre.In_isWaterMeterFailing,
      In_mode = pre.In_mode,
      In_p0 = pre.In_p0,
      In_p1 = pre.In_p1,
      In_p2 = pre.In_p2,
      In_p3 = pre.In_p3,
      In_q = pre.In_q,
      In_qa1 = pre.In_qa1,
      In_qa2 = pre.In_qa2,
      In_qc1 = pre.In_qc1,
      In_qc2 = pre.In_qc2,
      In_shouldUpdatePumps = pre.In_shouldUpdatePumps,
      In_transmissionFailure = pre.In_transmissionFailure,
      In_v_steamRate = pre.In_v_steamRate,
      C = post.C,
      M1 = post.M1,
      M2 = post.M2,
      N1 = post.N1,
      N2 = post.N2,
      P = post.P,
      U1 = post.U1,
      U2 = post.U2,
      W = post.W,
      hasBoilerSentWaiting = post.hasBoilerSentWaiting,
      isPump0Failing = post.isPump0Failing,
      isPump1Failing = post.isPump1Failing,
      isPump2Failing = post.isPump2Failing,
      isPump3Failing = post.isPump3Failing,
      isSteamMeterFailing = post.isSteamMeterFailing,
      isWaterMeterFailing = post.isWaterMeterFailing,
      mode = post.mode,
      p0 = post.p0,
      p1 = post.p1,
      p2 = post.p2,
      p3 = post.p3,
      q = post.q,
      qa1 = post.qa1,
      qa2 = post.qa2,
      qc1 = post.qc1,
      qc2 = post.qc2,
      shouldUpdatePumps = post.shouldUpdatePumps,
      transmissionFailure = post.transmissionFailure,
      v_steamRate = post.v_steamRate,
      api_boilerReady = pre.api_boilerReady,
      api_boilerWaiting = pre.api_boilerWaiting,
      api_levelRepair = pre.api_levelRepair,
      api_pumpControlReady0 = pre.api_pumpControlReady0,
      api_pumpControlReady1 = pre.api_pumpControlReady1,
      api_pumpControlReady2 = pre.api_pumpControlReady2,
      api_pumpControlReady3 = pre.api_pumpControlReady3,
      api_pumpRepair0 = pre.api_pumpRepair0,
      api_pumpRepair1 = pre.api_pumpRepair1,
      api_pumpRepair2 = pre.api_pumpRepair2,
      api_pumpRepair3 = pre.api_pumpRepair3,
      api_steamMeterReady = pre.api_steamMeterReady,
      api_steamRepair = pre.api_steamRepair,
      api_stop = pre.api_stop,
      api_waterMeterReady = pre.api_waterMeterReady,
      api_pumpFlow0 = pre.api_pumpFlow0,
      api_pumpFlow1 = pre.api_pumpFlow1,
      api_pumpFlow2 = pre.api_pumpFlow2,
      api_pumpFlow3 = pre.api_pumpFlow3,
      api_pumpOpen0 = pre.api_pumpOpen0,
      api_pumpOpen1 = pre.api_pumpOpen1,
      api_pumpOpen2 = pre.api_pumpOpen2,
      api_pumpOpen3 = pre.api_pumpOpen3,
      api_steamRate = pre.api_steamRate,
      api_waterLevel = pre.api_waterLevel,
      api_levelFail = post.api_levelFail,
      api_levelRepairAck = post.api_levelRepairAck,
      api_pumpControlFail0 = post.api_pumpControlFail0,
      api_pumpControlFail1 = post.api_pumpControlFail1,
      api_pumpControlFail2 = post.api_pumpControlFail2,
      api_pumpControlFail3 = post.api_pumpControlFail3,
      api_pumpControlRepairAck0 = post.api_pumpControlRepairAck0,
      api_pumpControlRepairAck1 = post.api_pumpControlRepairAck1,
      api_pumpControlRepairAck2 = post.api_pumpControlRepairAck2,
      api_pumpControlRepairAck3 = post.api_pumpControlRepairAck3,
      api_pumpFail0 = post.api_pumpFail0,
      api_pumpFail1 = post.api_pumpFail1,
      api_pumpFail2 = post.api_pumpFail2,
      api_pumpFail3 = post.api_pumpFail3,
      api_pumpRepairAck0 = post.api_pumpRepairAck0,
      api_pumpRepairAck1 = post.api_pumpRepairAck1,
      api_pumpRepairAck2 = post.api_pumpRepairAck2,
      api_pumpRepairAck3 = post.api_pumpRepairAck3,
      api_ready = post.api_ready,
      api_steamFail = post.api_steamFail,
      api_steamRepairAck = post.api_steamRepairAck,
      api_valve = post.api_valve,
      api_opMode = post.api_opMode,
      api_openPump0 = post.api_openPump0,
      api_openPump1 = post.api_openPump1,
      api_openPump2 = post.api_openPump2,
      api_openPump3 = post.api_openPump3)
}
