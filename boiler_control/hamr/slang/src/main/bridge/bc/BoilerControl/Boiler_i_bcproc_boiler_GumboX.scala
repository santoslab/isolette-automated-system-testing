// #Sireum

package bc.BoilerControl

import org.sireum._
import bc._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun
object Boiler_i_bcproc_boiler_GumboX {
  /** Initialize Entrypoint Contract
    *
    * guarantee REQ_BOILER_INIT_1
    *   When the system Initializes, the Boiler must send a Waiting event.
    * @param api_waiting outgoing event port
    */
  @strictpure def initialize_REQ_BOILER_INIT_1 (
      api_waiting: Option[art.Empty]): B =
    api_waiting.nonEmpty

  /** Initialize Entrypoint Contract
    *
    * guarantee REQ_BOILER_INIT_2
    *   When the system Initializes, the Boiler's state variable, Mode, must be Init.
    * @param Mode post-state state variable
    */
  @strictpure def initialize_REQ_BOILER_INIT_2 (
      Mode: BoilerControl.OpMode.Type): B =
    Mode == BoilerControl.OpMode.Init

  /** Initialize Entrypoint Contract
    *
    * guarantee REQ_BOILER_INIT_3
    *   When the system Initializes, the valve should not be open.
    * @param ValveOpen post-state state variable
    */
  @strictpure def initialize_REQ_BOILER_INIT_3 (
      ValveOpen: Base_Types.Boolean): B =
    !ValveOpen

  /** Initialize Entrypoint Contract
    *
    * guarantee REQ_BOILER_INIT_4
    *   When the system Initializes, the Boiler must not send a Ready event.
    * @param api_ready outgoing event port
    */
  @strictpure def initialize_REQ_BOILER_INIT_4 (
      api_ready: Option[art.Empty]): B =
    api_ready.isEmpty

  /** IEP-Guar: Initialize Entrypoint Contracts for boiler
    *
    * @param Mode post-state state variable
    * @param ValveOpen post-state state variable
    * @param api_ready outgoing event port
    * @param api_waiting outgoing event port
    */
  @strictpure def initialize_IEP_Guar (
      Mode: BoilerControl.OpMode.Type,
      ValveOpen: Base_Types.Boolean,
      api_ready: Option[art.Empty],
      api_waiting: Option[art.Empty]): B =
    initialize_REQ_BOILER_INIT_1(api_waiting) &
    initialize_REQ_BOILER_INIT_2(Mode) &
    initialize_REQ_BOILER_INIT_3(ValveOpen) &
    initialize_REQ_BOILER_INIT_4(api_ready)

  /** IEP-Post: Initialize Entrypoint Post-Condition
    *
    * @param Mode post-state state variable
    * @param ValveOpen post-state state variable
    * @param api_ready outgoing event port
    * @param api_waiting outgoing event port
    */
  @strictpure def inititialize_IEP_Post (
      Mode: BoilerControl.OpMode.Type,
      ValveOpen: Base_Types.Boolean,
      api_ready: Option[art.Empty],
      api_waiting: Option[art.Empty]): B =
    (// IEP-Guar: Initialize Entrypoint contract for boiler
     initialize_IEP_Guar(Mode, ValveOpen, api_ready, api_waiting))

  /** IEP-Post: Initialize Entrypoint Post-Condition via container
    *
    * @param post Container holding the value of incoming ports and the pre-state values of state variables
    */
  @strictpure def inititialize_IEP_Post_Container (post: Boiler_i_bcproc_boiler_PostState_Container_PS): B =
    inititialize_IEP_Post (
      Mode = post.Mode,
      ValveOpen = post.ValveOpen,
      api_ready = post.api_ready,
      api_waiting = post.api_waiting)

  /** guarantee REQ_BOILER_COMP_1
    *   If OpMode is Init and Valve has an event, then Open the Valve (OpenValve == True)
    * @param In_Mode pre-state state variable
    * @param ValveOpen post-state state variable
    * @param api_valve incoming event port
    * @param api_opMode incoming event data port
    */
  @strictpure def compute_case_REQ_BOILER_COMP_1(
      In_Mode: BoilerControl.OpMode.Type,
      ValveOpen: Base_Types.Boolean,
      api_valve: Option[art.Empty],
      api_opMode: Option[BoilerControl.OpMode.Type]): B =
    ((api_opMode.nonEmpty &&
        api_opMode.get == BoilerControl.OpMode.Init ||
        In_Mode == BoilerControl.OpMode.Init &&
          !(api_opMode.nonEmpty)) &&
       api_valve.nonEmpty) -->:
      (ValveOpen)

  /** guarantee REQ_BOILER_COMP_2
    *   If OpMode is Init and has received the ProgramReady event, then Boiler should send the Ready message.
    * @param In_Mode pre-state state variable
    * @param api_programReady incoming event port
    * @param api_opMode incoming event data port
    * @param api_ready outgoing event port
    */
  @strictpure def compute_case_REQ_BOILER_COMP_2(
      In_Mode: BoilerControl.OpMode.Type,
      api_programReady: Option[art.Empty],
      api_opMode: Option[BoilerControl.OpMode.Type],
      api_ready: Option[art.Empty]): B =
    ((api_opMode.nonEmpty &&
        api_opMode.get == BoilerControl.OpMode.Init ||
        In_Mode == BoilerControl.OpMode.Init &&
          !(api_opMode.nonEmpty)) &&
       api_programReady.nonEmpty) -->:
      (api_ready.nonEmpty)

  /** guarantee REQ_BOILER_COMP_3
    *   If OpMode is not Init or Boiler has not received the Valve event, then the Valve remains unchanged.
    * @param In_Mode pre-state state variable
    * @param In_ValveOpen pre-state state variable
    * @param ValveOpen post-state state variable
    * @param api_valve incoming event port
    * @param api_opMode incoming event data port
    */
  @strictpure def compute_case_REQ_BOILER_COMP_3(
      In_Mode: BoilerControl.OpMode.Type,
      In_ValveOpen: Base_Types.Boolean,
      ValveOpen: Base_Types.Boolean,
      api_valve: Option[art.Empty],
      api_opMode: Option[BoilerControl.OpMode.Type]): B =
    (!((api_opMode.nonEmpty &&
        api_opMode.get == BoilerControl.OpMode.Init ||
        In_Mode == BoilerControl.OpMode.Init &&
          !(api_opMode.nonEmpty)) &&
        api_valve.nonEmpty)) -->:
      (In_ValveOpen == ValveOpen)

  /** guarantee REQ_BOILER_COMP_4
    *   If OpMode is not Init or Boiler has not received the ProgramReady event, then Boiler will not send the Ready message.
    * @param In_Mode pre-state state variable
    * @param api_programReady incoming event port
    * @param api_opMode incoming event data port
    * @param api_ready outgoing event port
    */
  @strictpure def compute_case_REQ_BOILER_COMP_4(
      In_Mode: BoilerControl.OpMode.Type,
      api_programReady: Option[art.Empty],
      api_opMode: Option[BoilerControl.OpMode.Type],
      api_ready: Option[art.Empty]): B =
    (!((api_opMode.nonEmpty &&
        api_opMode.get == BoilerControl.OpMode.Init ||
        In_Mode == BoilerControl.OpMode.Init &&
          !(api_opMode.nonEmpty)) &&
        api_programReady.nonEmpty)) -->:
      (api_ready.isEmpty)

  /** guarantee REQ_BOILER_COMP_5
    *   The Waiting message must never be sent (This is because it is sent when the component is initialized, and only once, so it should not be done here).
    * @param api_waiting outgoing event port
    */
  @strictpure def compute_case_REQ_BOILER_COMP_5(
      api_waiting: Option[art.Empty]): B =
    (T) -->:
      (api_waiting.isEmpty)

  /** CEP-T-Case: Top-Level case contracts for boiler's compute entrypoint
    *
    * @param In_Mode pre-state state variable
    * @param In_ValveOpen pre-state state variable
    * @param ValveOpen post-state state variable
    * @param api_programReady incoming event port
    * @param api_valve incoming event port
    * @param api_opMode incoming event data port
    * @param api_ready outgoing event port
    * @param api_waiting outgoing event port
    */
  @strictpure def compute_CEP_T_Case (
      In_Mode: BoilerControl.OpMode.Type,
      In_ValveOpen: Base_Types.Boolean,
      ValveOpen: Base_Types.Boolean,
      api_programReady: Option[art.Empty],
      api_valve: Option[art.Empty],
      api_opMode: Option[BoilerControl.OpMode.Type],
      api_ready: Option[art.Empty],
      api_waiting: Option[art.Empty]): B =
    compute_case_REQ_BOILER_COMP_1(In_Mode, ValveOpen, api_valve, api_opMode) &
    compute_case_REQ_BOILER_COMP_2(In_Mode, api_programReady, api_opMode, api_ready) &
    compute_case_REQ_BOILER_COMP_3(In_Mode, In_ValveOpen, ValveOpen, api_valve, api_opMode) &
    compute_case_REQ_BOILER_COMP_4(In_Mode, api_programReady, api_opMode, api_ready) &
    compute_case_REQ_BOILER_COMP_5(api_waiting)

  /** CEP-Post: Compute Entrypoint Post-Condition for boiler
    *
    * @param In_Mode pre-state state variable
    * @param In_ValveOpen pre-state state variable
    * @param Mode post-state state variable
    * @param ValveOpen post-state state variable
    * @param api_programReady incoming event port
    * @param api_valve incoming event port
    * @param api_opMode incoming event data port
    * @param api_ready outgoing event port
    * @param api_waiting outgoing event port
    */
  @strictpure def compute_CEP_Post (
      In_Mode: BoilerControl.OpMode.Type,
      In_ValveOpen: Base_Types.Boolean,
      Mode: BoilerControl.OpMode.Type,
      ValveOpen: Base_Types.Boolean,
      api_programReady: Option[art.Empty],
      api_valve: Option[art.Empty],
      api_opMode: Option[BoilerControl.OpMode.Type],
      api_ready: Option[art.Empty],
      api_waiting: Option[art.Empty]): B =
    (// CEP-T-Case: case clauses of boiler's compute entrypoint
     compute_CEP_T_Case (In_Mode, In_ValveOpen, ValveOpen, api_programReady, api_valve, api_opMode, api_ready, api_waiting))

  /** CEP-Post: Compute Entrypoint Post-Condition for boiler via containers
    *
    * @param pre Container holding the values of incoming ports and the pre-state values of state variables
    * @param post Container holding the values of outgoing ports and the post-state values of state variables
    */
  @strictpure def compute_CEP_Post_Container(
      pre: Boiler_i_bcproc_boiler_PreState_Container_PS,
      post: Boiler_i_bcproc_boiler_PostState_Container_PS): B =
    compute_CEP_Post(
      In_Mode = pre.In_Mode,
      In_ValveOpen = pre.In_ValveOpen,
      Mode = post.Mode,
      ValveOpen = post.ValveOpen,
      api_programReady = pre.api_programReady,
      api_valve = pre.api_valve,
      api_opMode = pre.api_opMode,
      api_ready = post.api_ready,
      api_waiting = post.api_waiting)
}
