// #Sireum

package bc.BoilerControl

import org.sireum._
import bc._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun
object SteamMeter_i_bcproc_steamMeter_GumboX {
  /** Initialize Entrypoint Contract
    *
    * guarantee REQ_STEAM_INIT_1
    *   level message is sent with volume as its value.
    * @param computedRate post-state state variable
    * @param api_rate outgoing event data port
    */
  @strictpure def initialize_REQ_STEAM_INIT_1 (
      computedRate: Base_Types.Float_32,
      api_rate: Option[Base_Types.Float_32]): B =
    api_rate.nonEmpty &&
      api_rate.get == computedRate

  /** Initialize Entrypoint Contract
    *
    * guarantee REQ_STEAM_INIT_2
    *   ready message is not sent during initialization.
    * @param api_ready outgoing event port
    */
  @strictpure def initialize_REQ_STEAM_INIT_2 (
      api_ready: Option[art.Empty]): B =
    api_ready.isEmpty

  /** Initialize Entrypoint Contract
    *
    * guarantee REQ_STEAM_INIT_3
    *   computedRate, the local variable for the Steam Meter is the volume of steam recorded from the reader divided by 5 (each compute cycle in the system is 5 seconds apart). Note, the amount of steam recorded from a lower level hardware is presumed in this system implementation to provide the volume read between each of its cycles. This was also done so that way there is a computational element to the reading for logika and other testers to have to deal with division. It is likely in other implementations that it would be returning the rate, and thus, the rate would be supplied to the port directly.
    * @param computedRate post-state state variable
    * @param volume post-state state variable
    */
  @strictpure def initialize_REQ_STEAM_INIT_3 (
      computedRate: Base_Types.Float_32,
      volume: Base_Types.Float_32): B =
    computedRate == volume / 5.0f

  /** IEP-Guar: Initialize Entrypoint Contracts for steamMeter
    *
    * @param computedRate post-state state variable
    * @param volume post-state state variable
    * @param api_ready outgoing event port
    * @param api_rate outgoing event data port
    */
  @strictpure def initialize_IEP_Guar (
      computedRate: Base_Types.Float_32,
      volume: Base_Types.Float_32,
      api_ready: Option[art.Empty],
      api_rate: Option[Base_Types.Float_32]): B =
    initialize_REQ_STEAM_INIT_1(computedRate, api_rate) &
    initialize_REQ_STEAM_INIT_2(api_ready) &
    initialize_REQ_STEAM_INIT_3(computedRate, volume)

  /** IEP-Post: Initialize Entrypoint Post-Condition
    *
    * @param computedRate post-state state variable
    * @param volume post-state state variable
    * @param api_ready outgoing event port
    * @param api_rate outgoing event data port
    */
  @strictpure def inititialize_IEP_Post (
      computedRate: Base_Types.Float_32,
      volume: Base_Types.Float_32,
      api_ready: Option[art.Empty],
      api_rate: Option[Base_Types.Float_32]): B =
    (// IEP-Guar: Initialize Entrypoint contract for steamMeter
     initialize_IEP_Guar(computedRate, volume, api_ready, api_rate))

  /** IEP-Post: Initialize Entrypoint Post-Condition via container
    *
    * @param post Container holding the value of incoming ports and the pre-state values of state variables
    */
  @strictpure def inititialize_IEP_Post_Container (post: SteamMeter_i_bcproc_steamMeter_PostState_Container_PS): B =
    inititialize_IEP_Post (
      computedRate = post.computedRate,
      volume = post.volume,
      api_ready = post.api_ready,
      api_rate = post.api_rate)

  /** guarantee REQ_STEAM_COMP_1
    *   If programReady has an event, then a ready event must be sent if the component is ready.
    * @param api_programReady incoming event port
    * @param api_ready outgoing event port
    */
  @strictpure def compute_case_REQ_STEAM_COMP_1(
      api_programReady: Option[art.Empty],
      api_ready: Option[art.Empty]): B =
    (api_programReady.nonEmpty) -->:
      (api_ready.nonEmpty)

  /** guarantee REQ_STEAM_COMP_2
    *   If programReady does not have an event, then a ready event can not be sent.
    * @param api_programReady incoming event port
    * @param api_ready outgoing event port
    */
  @strictpure def compute_case_REQ_STEAM_COMP_2(
      api_programReady: Option[art.Empty],
      api_ready: Option[art.Empty]): B =
    (!(api_programReady.nonEmpty)) -->:
      (api_ready.isEmpty)

  /** guarantee REQ_STEAM_COMP_3
    *   Each computational cycle, the Steam Meter will send the computedRate through a rate message.
    * @param computedRate post-state state variable
    * @param api_rate outgoing event data port
    */
  @strictpure def compute_case_REQ_STEAM_COMP_3(
      computedRate: Base_Types.Float_32,
      api_rate: Option[Base_Types.Float_32]): B =
    (T) -->:
      (api_rate.nonEmpty &&
         api_rate.get == computedRate)

  /** guarantee REQ_STEAM_COMP_4
    *   computedRate, the local variable for the Steam Meter is the volume of steam recorded from the reader divided by 5 (each compute cycle in the system is 5 seconds apart). Note, the amount of steam recorded from a lower level hardware is presumed in this system implementation to provide the volume read between each of its cycles. This was also done so that way there is a computational element to the reading for logika and other testers to have to deal with division. It is likely in other implementations that it would be returning the rate, and thus, the rate would be supplied to the port directly.
    * @param computedRate post-state state variable
    * @param volume post-state state variable
    */
  @strictpure def compute_case_REQ_STEAM_COMP_4(
      computedRate: Base_Types.Float_32,
      volume: Base_Types.Float_32): B =
    (T) -->:
      (computedRate == volume / 5.0f)

  /** CEP-T-Case: Top-Level case contracts for steamMeter's compute entrypoint
    *
    * @param computedRate post-state state variable
    * @param volume post-state state variable
    * @param api_programReady incoming event port
    * @param api_ready outgoing event port
    * @param api_rate outgoing event data port
    */
  @strictpure def compute_CEP_T_Case (
      computedRate: Base_Types.Float_32,
      volume: Base_Types.Float_32,
      api_programReady: Option[art.Empty],
      api_ready: Option[art.Empty],
      api_rate: Option[Base_Types.Float_32]): B =
    compute_case_REQ_STEAM_COMP_1(api_programReady, api_ready) &
    compute_case_REQ_STEAM_COMP_2(api_programReady, api_ready) &
    compute_case_REQ_STEAM_COMP_3(computedRate, api_rate) &
    compute_case_REQ_STEAM_COMP_4(computedRate, volume)

  /** CEP-Post: Compute Entrypoint Post-Condition for steamMeter
    *
    * @param In_computedRate pre-state state variable
    * @param In_volume pre-state state variable
    * @param computedRate post-state state variable
    * @param volume post-state state variable
    * @param api_programReady incoming event port
    * @param api_ready outgoing event port
    * @param api_rate outgoing event data port
    */
  @strictpure def compute_CEP_Post (
      In_computedRate: Base_Types.Float_32,
      In_volume: Base_Types.Float_32,
      computedRate: Base_Types.Float_32,
      volume: Base_Types.Float_32,
      api_programReady: Option[art.Empty],
      api_ready: Option[art.Empty],
      api_rate: Option[Base_Types.Float_32]): B =
    (// CEP-T-Case: case clauses of steamMeter's compute entrypoint
     compute_CEP_T_Case (computedRate, volume, api_programReady, api_ready, api_rate))

  /** CEP-Post: Compute Entrypoint Post-Condition for steamMeter via containers
    *
    * @param pre Container holding the values of incoming ports and the pre-state values of state variables
    * @param post Container holding the values of outgoing ports and the post-state values of state variables
    */
  @strictpure def compute_CEP_Post_Container(
      pre: SteamMeter_i_bcproc_steamMeter_PreState_Container_PS,
      post: SteamMeter_i_bcproc_steamMeter_PostState_Container_PS): B =
    compute_CEP_Post(
      In_computedRate = pre.In_computedRate,
      In_volume = pre.In_volume,
      computedRate = post.computedRate,
      volume = post.volume,
      api_programReady = pre.api_programReady,
      api_ready = post.api_ready,
      api_rate = post.api_rate)
}
