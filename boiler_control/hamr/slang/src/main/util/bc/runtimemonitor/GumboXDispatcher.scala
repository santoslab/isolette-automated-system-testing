// #Sireum

package bc.runtimemonitor

import org.sireum._
import bc._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object GumboXDispatcher {
  def checkContract(observationKind: ObservationKind.Type, preContainer: Option[art.DataContent], postContainer: Option[art.DataContent]): B = {
    observationKind match {
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_boiler_postInit =>
        val result: B = bc.BoilerControl.Boiler_i_bcproc_boiler_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[bc.BoilerControl.Boiler_i_bcproc_boiler_PostState_Container_PS])
        //println(s"boiler.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_boiler_preCompute =>
        // checking the pre-state values of boiler's compute entrypoint is not required
        return T
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_boiler_postCompute =>
        val result: B = bc.BoilerControl.Boiler_i_bcproc_boiler_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[bc.BoilerControl.Boiler_i_bcproc_boiler_PreState_Container_PS], postContainer.get.asInstanceOf[bc.BoilerControl.Boiler_i_bcproc_boiler_PostState_Container_PS])
        //println(s"boiler.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl0_postInit =>
        val result: B = bc.BoilerControl.PumpControl_i_bcproc_pumpControl0_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl0_PostState_Container_PS])
        //println(s"pumpControl0.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl0_preCompute =>
        // checking the pre-state values of pumpControl0's compute entrypoint is not required
        return T
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl0_postCompute =>
        val result: B = bc.BoilerControl.PumpControl_i_bcproc_pumpControl0_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl0_PreState_Container_PS], postContainer.get.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl0_PostState_Container_PS])
        //println(s"pumpControl0.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl1_postInit =>
        val result: B = bc.BoilerControl.PumpControl_i_bcproc_pumpControl1_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl1_PostState_Container_PS])
        //println(s"pumpControl1.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl1_preCompute =>
        // checking the pre-state values of pumpControl1's compute entrypoint is not required
        return T
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl1_postCompute =>
        val result: B = bc.BoilerControl.PumpControl_i_bcproc_pumpControl1_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl1_PreState_Container_PS], postContainer.get.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl1_PostState_Container_PS])
        //println(s"pumpControl1.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl2_postInit =>
        val result: B = bc.BoilerControl.PumpControl_i_bcproc_pumpControl2_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl2_PostState_Container_PS])
        //println(s"pumpControl2.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl2_preCompute =>
        // checking the pre-state values of pumpControl2's compute entrypoint is not required
        return T
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl2_postCompute =>
        val result: B = bc.BoilerControl.PumpControl_i_bcproc_pumpControl2_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl2_PreState_Container_PS], postContainer.get.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl2_PostState_Container_PS])
        //println(s"pumpControl2.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl3_postInit =>
        val result: B = bc.BoilerControl.PumpControl_i_bcproc_pumpControl3_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl3_PostState_Container_PS])
        //println(s"pumpControl3.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl3_preCompute =>
        // checking the pre-state values of pumpControl3's compute entrypoint is not required
        return T
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl3_postCompute =>
        val result: B = bc.BoilerControl.PumpControl_i_bcproc_pumpControl3_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl3_PreState_Container_PS], postContainer.get.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl3_PostState_Container_PS])
        //println(s"pumpControl3.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_waterMeter_postInit =>
        val result: B = bc.BoilerControl.WaterMeter_i_bcproc_waterMeter_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[bc.BoilerControl.WaterMeter_i_bcproc_waterMeter_PostState_Container_PS])
        //println(s"waterMeter.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_waterMeter_preCompute =>
        // checking the pre-state values of waterMeter's compute entrypoint is not required
        return T
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_waterMeter_postCompute =>
        val result: B = bc.BoilerControl.WaterMeter_i_bcproc_waterMeter_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[bc.BoilerControl.WaterMeter_i_bcproc_waterMeter_PreState_Container_PS], postContainer.get.asInstanceOf[bc.BoilerControl.WaterMeter_i_bcproc_waterMeter_PostState_Container_PS])
        //println(s"waterMeter.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_steamMeter_postInit =>
        val result: B = bc.BoilerControl.SteamMeter_i_bcproc_steamMeter_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[bc.BoilerControl.SteamMeter_i_bcproc_steamMeter_PostState_Container_PS])
        //println(s"steamMeter.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_steamMeter_preCompute =>
        // checking the pre-state values of steamMeter's compute entrypoint is not required
        return T
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_steamMeter_postCompute =>
        val result: B = bc.BoilerControl.SteamMeter_i_bcproc_steamMeter_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[bc.BoilerControl.SteamMeter_i_bcproc_steamMeter_PreState_Container_PS], postContainer.get.asInstanceOf[bc.BoilerControl.SteamMeter_i_bcproc_steamMeter_PostState_Container_PS])
        //println(s"steamMeter.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_desk_postInit =>
        val result: B = bc.BoilerControl.OperatorDesk_i_bcproc_desk_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[bc.BoilerControl.OperatorDesk_i_bcproc_desk_PostState_Container_PS])
        //println(s"desk.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_desk_preCompute =>
        // checking the pre-state values of desk's compute entrypoint is not required
        return T
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_desk_postCompute =>
        val result: B = bc.BoilerControl.OperatorDesk_i_bcproc_desk_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[bc.BoilerControl.OperatorDesk_i_bcproc_desk_PreState_Container_PS], postContainer.get.asInstanceOf[bc.BoilerControl.OperatorDesk_i_bcproc_desk_PostState_Container_PS])
        //println(s"desk.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_control_postInit =>
        val result: B = bc.BoilerControl.BoilerControl_i_bcproc_control_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[bc.BoilerControl.BoilerControl_i_bcproc_control_PostState_Container_PS])
        //println(s"control.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_control_preCompute =>
        // checking the pre-state values of control's compute entrypoint is not required
        return T
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_control_postCompute =>
        val result: B = bc.BoilerControl.BoilerControl_i_bcproc_control_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[bc.BoilerControl.BoilerControl_i_bcproc_control_PreState_Container_PS], postContainer.get.asInstanceOf[bc.BoilerControl.BoilerControl_i_bcproc_control_PostState_Container_PS])
        //println(s"control.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case _ => halt("Infeasible")
    }
  }

  def genTestSuite(testCases: ISZ[(Z, ISZ[ST])]): Unit = {
    val tq = "\"\"\""

    val testRoot = Os.path(".") / "src" / "test" / "bridge"

    val Boiler_i_bcproc_boiler_id = Arch.BoilerControlSystem_i_Instance_bcproc_boiler.id
    val PumpControl_i_bcproc_pumpControl0_id = Arch.BoilerControlSystem_i_Instance_bcproc_pumpControl0.id
    val PumpControl_i_bcproc_pumpControl1_id = Arch.BoilerControlSystem_i_Instance_bcproc_pumpControl1.id
    val PumpControl_i_bcproc_pumpControl2_id = Arch.BoilerControlSystem_i_Instance_bcproc_pumpControl2.id
    val PumpControl_i_bcproc_pumpControl3_id = Arch.BoilerControlSystem_i_Instance_bcproc_pumpControl3.id
    val WaterMeter_i_bcproc_waterMeter_id = Arch.BoilerControlSystem_i_Instance_bcproc_waterMeter.id
    val SteamMeter_i_bcproc_steamMeter_id = Arch.BoilerControlSystem_i_Instance_bcproc_steamMeter.id
    val OperatorDesk_i_bcproc_desk_id = Arch.BoilerControlSystem_i_Instance_bcproc_desk.id
    val BoilerControl_i_bcproc_control_id = Arch.BoilerControlSystem_i_Instance_bcproc_control.id

    def genUniqueSuiteName(path: Os.Path, prefix: String): String = {
      var i = 0
      while(true) {
        val cand = path / s"${prefix}_${i}.scala"
        if (!cand.exists) {
          return s"${prefix}_${i}"
        }
        i = i + 1
      }
      halt("Infeasible")
    }

    for (p <- testCases) {
      art.Art.BridgeId.fromZ(p._1) match {
        case Boiler_i_bcproc_boiler_id =>
          val prefix = "Boiler_i_bcproc_boiler_RM_TestSuite"
          val path = testRoot /+ ISZ("bc","BoilerControl")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package bc.BoilerControl
                |
                |import org.sireum._
                |import bc.BoilerControl._
                |
                |class ${suiteName} extends Boiler_i_bcproc_boiler_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case PumpControl_i_bcproc_pumpControl0_id =>
          val prefix = "PumpControl_i_bcproc_pumpControl0_RM_TestSuite"
          val path = testRoot /+ ISZ("bc","BoilerControl")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package bc.BoilerControl
                |
                |import org.sireum._
                |import bc.BoilerControl._
                |
                |class ${suiteName} extends PumpControl_i_bcproc_pumpControl0_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case PumpControl_i_bcproc_pumpControl1_id =>
          val prefix = "PumpControl_i_bcproc_pumpControl1_RM_TestSuite"
          val path = testRoot /+ ISZ("bc","BoilerControl")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package bc.BoilerControl
                |
                |import org.sireum._
                |import bc.BoilerControl._
                |
                |class ${suiteName} extends PumpControl_i_bcproc_pumpControl1_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case PumpControl_i_bcproc_pumpControl2_id =>
          val prefix = "PumpControl_i_bcproc_pumpControl2_RM_TestSuite"
          val path = testRoot /+ ISZ("bc","BoilerControl")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package bc.BoilerControl
                |
                |import org.sireum._
                |import bc.BoilerControl._
                |
                |class ${suiteName} extends PumpControl_i_bcproc_pumpControl2_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case PumpControl_i_bcproc_pumpControl3_id =>
          val prefix = "PumpControl_i_bcproc_pumpControl3_RM_TestSuite"
          val path = testRoot /+ ISZ("bc","BoilerControl")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package bc.BoilerControl
                |
                |import org.sireum._
                |import bc.BoilerControl._
                |
                |class ${suiteName} extends PumpControl_i_bcproc_pumpControl3_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case WaterMeter_i_bcproc_waterMeter_id =>
          val prefix = "WaterMeter_i_bcproc_waterMeter_RM_TestSuite"
          val path = testRoot /+ ISZ("bc","BoilerControl")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package bc.BoilerControl
                |
                |import org.sireum._
                |import bc.BoilerControl._
                |
                |class ${suiteName} extends WaterMeter_i_bcproc_waterMeter_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case SteamMeter_i_bcproc_steamMeter_id =>
          val prefix = "SteamMeter_i_bcproc_steamMeter_RM_TestSuite"
          val path = testRoot /+ ISZ("bc","BoilerControl")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package bc.BoilerControl
                |
                |import org.sireum._
                |import bc.BoilerControl._
                |
                |class ${suiteName} extends SteamMeter_i_bcproc_steamMeter_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case OperatorDesk_i_bcproc_desk_id =>
          val prefix = "OperatorDesk_i_bcproc_desk_RM_TestSuite"
          val path = testRoot /+ ISZ("bc","BoilerControl")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package bc.BoilerControl
                |
                |import org.sireum._
                |import bc.BoilerControl._
                |
                |class ${suiteName} extends OperatorDesk_i_bcproc_desk_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case BoilerControl_i_bcproc_control_id =>
          val prefix = "BoilerControl_i_bcproc_control_RM_TestSuite"
          val path = testRoot /+ ISZ("bc","BoilerControl")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package bc.BoilerControl
                |
                |import org.sireum._
                |import bc.BoilerControl._
                |
                |class ${suiteName} extends BoilerControl_i_bcproc_control_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case x => halt(s"Infeasible bridge id: $x")
      }
    }
  }

  def genTestCase(observationKind: ObservationKind.Type, preContainer: Option[String], postContainer: Option[String], testNameSuffix: Option[String]): ST = {
    val tq = "\"\"\""
    val suffix: String =
      if (testNameSuffix.nonEmpty) testNameSuffix.get
      else ""

    observationKind match {
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_boiler_postInit =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_boiler_postInit
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_boiler_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = bc.JSON.toBoilerControlBoiler_i_bcproc_boiler_PostState_Container_PS(postJson).left
                    |  assert(bc.BoilerControl.Boiler_i_bcproc_boiler_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_boiler_postInit""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_boiler_postCompute =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_boiler_postCompute
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_boiler_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = bc.JSON.toBoilerControlBoiler_i_bcproc_boiler_PreState_Container_PS(preJson).left
                    |  val postContainer = bc.JSON.toBoilerControlBoiler_i_bcproc_boiler_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(bc.BoilerControl.Boiler_i_bcproc_boiler_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_boiler_postCompute""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl0_postInit =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl0_postInit
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_pumpControl0_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = bc.JSON.toBoilerControlPumpControl_i_bcproc_pumpControl0_PostState_Container_PS(postJson).left
                    |  assert(bc.BoilerControl.PumpControl_i_bcproc_pumpControl0_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl0_postInit""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl0_postCompute =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl0_postCompute
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_pumpControl0_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = bc.JSON.toBoilerControlPumpControl_i_bcproc_pumpControl0_PreState_Container_PS(preJson).left
                    |  val postContainer = bc.JSON.toBoilerControlPumpControl_i_bcproc_pumpControl0_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(bc.BoilerControl.PumpControl_i_bcproc_pumpControl0_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl0_postCompute""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl1_postInit =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl1_postInit
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_pumpControl1_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = bc.JSON.toBoilerControlPumpControl_i_bcproc_pumpControl1_PostState_Container_PS(postJson).left
                    |  assert(bc.BoilerControl.PumpControl_i_bcproc_pumpControl1_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl1_postInit""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl1_postCompute =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl1_postCompute
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_pumpControl1_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = bc.JSON.toBoilerControlPumpControl_i_bcproc_pumpControl1_PreState_Container_PS(preJson).left
                    |  val postContainer = bc.JSON.toBoilerControlPumpControl_i_bcproc_pumpControl1_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(bc.BoilerControl.PumpControl_i_bcproc_pumpControl1_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl1_postCompute""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl2_postInit =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl2_postInit
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_pumpControl2_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = bc.JSON.toBoilerControlPumpControl_i_bcproc_pumpControl2_PostState_Container_PS(postJson).left
                    |  assert(bc.BoilerControl.PumpControl_i_bcproc_pumpControl2_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl2_postInit""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl2_postCompute =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl2_postCompute
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_pumpControl2_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = bc.JSON.toBoilerControlPumpControl_i_bcproc_pumpControl2_PreState_Container_PS(preJson).left
                    |  val postContainer = bc.JSON.toBoilerControlPumpControl_i_bcproc_pumpControl2_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(bc.BoilerControl.PumpControl_i_bcproc_pumpControl2_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl2_postCompute""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl3_postInit =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl3_postInit
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_pumpControl3_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = bc.JSON.toBoilerControlPumpControl_i_bcproc_pumpControl3_PostState_Container_PS(postJson).left
                    |  assert(bc.BoilerControl.PumpControl_i_bcproc_pumpControl3_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl3_postInit""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl3_postCompute =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl3_postCompute
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_pumpControl3_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = bc.JSON.toBoilerControlPumpControl_i_bcproc_pumpControl3_PreState_Container_PS(preJson).left
                    |  val postContainer = bc.JSON.toBoilerControlPumpControl_i_bcproc_pumpControl3_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(bc.BoilerControl.PumpControl_i_bcproc_pumpControl3_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_pumpControl3_postCompute""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_waterMeter_postInit =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_waterMeter_postInit
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_waterMeter_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = bc.JSON.toBoilerControlWaterMeter_i_bcproc_waterMeter_PostState_Container_PS(postJson).left
                    |  assert(bc.BoilerControl.WaterMeter_i_bcproc_waterMeter_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_waterMeter_postInit""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_waterMeter_postCompute =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_waterMeter_postCompute
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_waterMeter_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = bc.JSON.toBoilerControlWaterMeter_i_bcproc_waterMeter_PreState_Container_PS(preJson).left
                    |  val postContainer = bc.JSON.toBoilerControlWaterMeter_i_bcproc_waterMeter_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(bc.BoilerControl.WaterMeter_i_bcproc_waterMeter_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_waterMeter_postCompute""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_steamMeter_postInit =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_steamMeter_postInit
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_steamMeter_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = bc.JSON.toBoilerControlSteamMeter_i_bcproc_steamMeter_PostState_Container_PS(postJson).left
                    |  assert(bc.BoilerControl.SteamMeter_i_bcproc_steamMeter_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_steamMeter_postInit""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_steamMeter_postCompute =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_steamMeter_postCompute
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_steamMeter_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = bc.JSON.toBoilerControlSteamMeter_i_bcproc_steamMeter_PreState_Container_PS(preJson).left
                    |  val postContainer = bc.JSON.toBoilerControlSteamMeter_i_bcproc_steamMeter_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(bc.BoilerControl.SteamMeter_i_bcproc_steamMeter_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_steamMeter_postCompute""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_desk_postInit =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_desk_postInit
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_desk_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = bc.JSON.toBoilerControlOperatorDesk_i_bcproc_desk_PostState_Container_PS(postJson).left
                    |  assert(bc.BoilerControl.OperatorDesk_i_bcproc_desk_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_desk_postInit""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_desk_postCompute =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_desk_postCompute
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_desk_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = bc.JSON.toBoilerControlOperatorDesk_i_bcproc_desk_PreState_Container_PS(preJson).left
                    |  val postContainer = bc.JSON.toBoilerControlOperatorDesk_i_bcproc_desk_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(bc.BoilerControl.OperatorDesk_i_bcproc_desk_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_desk_postCompute""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_control_postInit =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_control_postInit
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_control_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = bc.JSON.toBoilerControlBoilerControl_i_bcproc_control_PostState_Container_PS(postJson).left
                    |  assert(bc.BoilerControl.BoilerControl_i_bcproc_control_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_control_postInit""")
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_control_postCompute =>
        return (st"""// Begin test cases for BoilerControlSystem_i_Instance_bcproc_control_postCompute
                    |
                    |test(s"BoilerControlSystem_i_Instance_bcproc_control_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = bc.JSON.toBoilerControlBoilerControl_i_bcproc_control_PreState_Container_PS(preJson).left
                    |  val postContainer = bc.JSON.toBoilerControlBoilerControl_i_bcproc_control_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(bc.BoilerControl.BoilerControl_i_bcproc_control_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for BoilerControlSystem_i_Instance_bcproc_control_postCompute""")
      case _ => return st"// TODO ${observationKind}"
    }
  }

  def getUpdates(bridge_id: art.Art.BridgeId, observationKind: ObservationKind.Type, container: art.DataContent): Map[String, String] = {
    observationKind match {
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_boiler_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.Boiler_i_bcproc_boiler_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_Mode" ~> postContainer.Mode.string
        updates = updates + s"${bridge_id}_Out_ValveOpen" ~> postContainer.ValveOpen.string
        if (postContainer.api_waiting.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_waiting" ~> postContainer.api_waiting.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl0_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl0_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_isPumpOpen" ~> postContainer.isPumpOpen.string
        updates = updates + s"${bridge_id}_Out_isPumpFlow" ~> postContainer.isPumpFlow.string
        updates = updates + s"${bridge_id}_Out_pumpNumber" ~> postContainer.pumpNumber.string
        if (postContainer.api_pumpOpen.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpOpen" ~> postContainer.api_pumpOpen.get.string
        }
        if (postContainer.api_pumpFlow.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFlow" ~> postContainer.api_pumpFlow.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl1_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl1_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_isPumpOpen" ~> postContainer.isPumpOpen.string
        updates = updates + s"${bridge_id}_Out_isPumpFlow" ~> postContainer.isPumpFlow.string
        updates = updates + s"${bridge_id}_Out_pumpNumber" ~> postContainer.pumpNumber.string
        if (postContainer.api_pumpOpen.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpOpen" ~> postContainer.api_pumpOpen.get.string
        }
        if (postContainer.api_pumpFlow.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFlow" ~> postContainer.api_pumpFlow.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl2_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl2_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_isPumpOpen" ~> postContainer.isPumpOpen.string
        updates = updates + s"${bridge_id}_Out_isPumpFlow" ~> postContainer.isPumpFlow.string
        updates = updates + s"${bridge_id}_Out_pumpNumber" ~> postContainer.pumpNumber.string
        if (postContainer.api_pumpOpen.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpOpen" ~> postContainer.api_pumpOpen.get.string
        }
        if (postContainer.api_pumpFlow.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFlow" ~> postContainer.api_pumpFlow.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl3_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl3_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_isPumpOpen" ~> postContainer.isPumpOpen.string
        updates = updates + s"${bridge_id}_Out_isPumpFlow" ~> postContainer.isPumpFlow.string
        updates = updates + s"${bridge_id}_Out_pumpNumber" ~> postContainer.pumpNumber.string
        if (postContainer.api_pumpOpen.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpOpen" ~> postContainer.api_pumpOpen.get.string
        }
        if (postContainer.api_pumpFlow.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFlow" ~> postContainer.api_pumpFlow.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_waterMeter_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.WaterMeter_i_bcproc_waterMeter_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_volume" ~> postContainer.volume.string
        if (postContainer.api_level.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_level" ~> postContainer.api_level.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_steamMeter_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.SteamMeter_i_bcproc_steamMeter_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_computedRate" ~> postContainer.computedRate.string
        updates = updates + s"${bridge_id}_Out_volume" ~> postContainer.volume.string
        if (postContainer.api_rate.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_rate" ~> postContainer.api_rate.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_desk_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.OperatorDesk_i_bcproc_desk_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_isPumpBroken0" ~> postContainer.isPumpBroken0.string
        updates = updates + s"${bridge_id}_Out_isPumpBroken1" ~> postContainer.isPumpBroken1.string
        updates = updates + s"${bridge_id}_Out_isPumpBroken2" ~> postContainer.isPumpBroken2.string
        updates = updates + s"${bridge_id}_Out_isPumpBroken3" ~> postContainer.isPumpBroken3.string
        updates = updates + s"${bridge_id}_Out_isPumpControlBroken0" ~> postContainer.isPumpControlBroken0.string
        updates = updates + s"${bridge_id}_Out_isPumpControlBroken1" ~> postContainer.isPumpControlBroken1.string
        updates = updates + s"${bridge_id}_Out_isPumpControlBroken2" ~> postContainer.isPumpControlBroken2.string
        updates = updates + s"${bridge_id}_Out_isPumpControlBroken3" ~> postContainer.isPumpControlBroken3.string
        updates = updates + s"${bridge_id}_Out_isLevelBroken" ~> postContainer.isLevelBroken.string
        updates = updates + s"${bridge_id}_Out_isSteamBroken" ~> postContainer.isSteamBroken.string
        if (postContainer.api_stop.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_stop" ~> postContainer.api_stop.get.string
        }
        if (postContainer.api_pumpRepair0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepair0" ~> postContainer.api_pumpRepair0.get.string
        }
        if (postContainer.api_pumpRepair1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepair1" ~> postContainer.api_pumpRepair1.get.string
        }
        if (postContainer.api_pumpRepair2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepair2" ~> postContainer.api_pumpRepair2.get.string
        }
        if (postContainer.api_pumpRepair3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepair3" ~> postContainer.api_pumpRepair3.get.string
        }
        if (postContainer.api_pumpControlRepair0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepair0" ~> postContainer.api_pumpControlRepair0.get.string
        }
        if (postContainer.api_pumpControlRepair1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepair1" ~> postContainer.api_pumpControlRepair1.get.string
        }
        if (postContainer.api_pumpControlRepair2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepair2" ~> postContainer.api_pumpControlRepair2.get.string
        }
        if (postContainer.api_pumpControlRepair3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepair3" ~> postContainer.api_pumpControlRepair3.get.string
        }
        if (postContainer.api_levelRepair.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_levelRepair" ~> postContainer.api_levelRepair.get.string
        }
        if (postContainer.api_steamRepair.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_steamRepair" ~> postContainer.api_steamRepair.get.string
        }
        if (postContainer.api_pumpFailAck0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFailAck0" ~> postContainer.api_pumpFailAck0.get.string
        }
        if (postContainer.api_pumpFailAck1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFailAck1" ~> postContainer.api_pumpFailAck1.get.string
        }
        if (postContainer.api_pumpFailAck2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFailAck2" ~> postContainer.api_pumpFailAck2.get.string
        }
        if (postContainer.api_pumpFailAck3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFailAck3" ~> postContainer.api_pumpFailAck3.get.string
        }
        if (postContainer.api_pumpControlFailAck0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFailAck0" ~> postContainer.api_pumpControlFailAck0.get.string
        }
        if (postContainer.api_pumpControlFailAck1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFailAck1" ~> postContainer.api_pumpControlFailAck1.get.string
        }
        if (postContainer.api_pumpControlFailAck2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFailAck2" ~> postContainer.api_pumpControlFailAck2.get.string
        }
        if (postContainer.api_pumpControlFailAck3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFailAck3" ~> postContainer.api_pumpControlFailAck3.get.string
        }
        if (postContainer.api_levelFailAck.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_levelFailAck" ~> postContainer.api_levelFailAck.get.string
        }
        if (postContainer.api_steamFailAck.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_steamFailAck" ~> postContainer.api_steamFailAck.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_control_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.BoilerControl_i_bcproc_control_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_mode" ~> postContainer.mode.string
        updates = updates + s"${bridge_id}_Out_C" ~> postContainer.C.string
        updates = updates + s"${bridge_id}_Out_M1" ~> postContainer.M1.string
        updates = updates + s"${bridge_id}_Out_M2" ~> postContainer.M2.string
        updates = updates + s"${bridge_id}_Out_N1" ~> postContainer.N1.string
        updates = updates + s"${bridge_id}_Out_N2" ~> postContainer.N2.string
        updates = updates + s"${bridge_id}_Out_W" ~> postContainer.W.string
        updates = updates + s"${bridge_id}_Out_U1" ~> postContainer.U1.string
        updates = updates + s"${bridge_id}_Out_U2" ~> postContainer.U2.string
        updates = updates + s"${bridge_id}_Out_q" ~> postContainer.q.string
        updates = updates + s"${bridge_id}_Out_P" ~> postContainer.P.string
        updates = updates + s"${bridge_id}_Out_v_steamRate" ~> postContainer.v_steamRate.string
        updates = updates + s"${bridge_id}_Out_hasBoilerSentWaiting" ~> postContainer.hasBoilerSentWaiting.string
        updates = updates + s"${bridge_id}_Out_isPump0Failing" ~> postContainer.isPump0Failing.string
        updates = updates + s"${bridge_id}_Out_isPump1Failing" ~> postContainer.isPump1Failing.string
        updates = updates + s"${bridge_id}_Out_isPump2Failing" ~> postContainer.isPump2Failing.string
        updates = updates + s"${bridge_id}_Out_isPump3Failing" ~> postContainer.isPump3Failing.string
        updates = updates + s"${bridge_id}_Out_isWaterMeterFailing" ~> postContainer.isWaterMeterFailing.string
        updates = updates + s"${bridge_id}_Out_isSteamMeterFailing" ~> postContainer.isSteamMeterFailing.string
        updates = updates + s"${bridge_id}_Out_p0" ~> postContainer.p0.string
        updates = updates + s"${bridge_id}_Out_p1" ~> postContainer.p1.string
        updates = updates + s"${bridge_id}_Out_p2" ~> postContainer.p2.string
        updates = updates + s"${bridge_id}_Out_p3" ~> postContainer.p3.string
        updates = updates + s"${bridge_id}_Out_qc1" ~> postContainer.qc1.string
        updates = updates + s"${bridge_id}_Out_qc2" ~> postContainer.qc2.string
        updates = updates + s"${bridge_id}_Out_qa1" ~> postContainer.qa1.string
        updates = updates + s"${bridge_id}_Out_qa2" ~> postContainer.qa2.string
        updates = updates + s"${bridge_id}_Out_shouldUpdatePumps" ~> postContainer.shouldUpdatePumps.string
        updates = updates + s"${bridge_id}_Out_transmissionFailure" ~> postContainer.transmissionFailure.string
        if (postContainer.api_opMode.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_opMode" ~> postContainer.api_opMode.get.string
        }
        if (postContainer.api_openPump0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_openPump0" ~> postContainer.api_openPump0.get.string
        }
        if (postContainer.api_openPump1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_openPump1" ~> postContainer.api_openPump1.get.string
        }
        if (postContainer.api_openPump2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_openPump2" ~> postContainer.api_openPump2.get.string
        }
        if (postContainer.api_openPump3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_openPump3" ~> postContainer.api_openPump3.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        if (postContainer.api_valve.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_valve" ~> postContainer.api_valve.get.string
        }
        if (postContainer.api_pumpFail0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFail0" ~> postContainer.api_pumpFail0.get.string
        }
        if (postContainer.api_pumpFail1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFail1" ~> postContainer.api_pumpFail1.get.string
        }
        if (postContainer.api_pumpFail2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFail2" ~> postContainer.api_pumpFail2.get.string
        }
        if (postContainer.api_pumpFail3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFail3" ~> postContainer.api_pumpFail3.get.string
        }
        if (postContainer.api_pumpControlFail0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFail0" ~> postContainer.api_pumpControlFail0.get.string
        }
        if (postContainer.api_pumpControlFail1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFail1" ~> postContainer.api_pumpControlFail1.get.string
        }
        if (postContainer.api_pumpControlFail2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFail2" ~> postContainer.api_pumpControlFail2.get.string
        }
        if (postContainer.api_pumpControlFail3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFail3" ~> postContainer.api_pumpControlFail3.get.string
        }
        if (postContainer.api_levelFail.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_levelFail" ~> postContainer.api_levelFail.get.string
        }
        if (postContainer.api_steamFail.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_steamFail" ~> postContainer.api_steamFail.get.string
        }
        if (postContainer.api_pumpRepairAck0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepairAck0" ~> postContainer.api_pumpRepairAck0.get.string
        }
        if (postContainer.api_pumpRepairAck1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepairAck1" ~> postContainer.api_pumpRepairAck1.get.string
        }
        if (postContainer.api_pumpRepairAck2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepairAck2" ~> postContainer.api_pumpRepairAck2.get.string
        }
        if (postContainer.api_pumpRepairAck3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepairAck3" ~> postContainer.api_pumpRepairAck3.get.string
        }
        if (postContainer.api_pumpControlRepairAck0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepairAck0" ~> postContainer.api_pumpControlRepairAck0.get.string
        }
        if (postContainer.api_pumpControlRepairAck1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepairAck1" ~> postContainer.api_pumpControlRepairAck1.get.string
        }
        if (postContainer.api_pumpControlRepairAck2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepairAck2" ~> postContainer.api_pumpControlRepairAck2.get.string
        }
        if (postContainer.api_pumpControlRepairAck3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepairAck3" ~> postContainer.api_pumpControlRepairAck3.get.string
        }
        if (postContainer.api_levelRepairAck.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_levelRepairAck" ~> postContainer.api_levelRepairAck.get.string
        }
        if (postContainer.api_steamRepairAck.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_steamRepairAck" ~> postContainer.api_steamRepairAck.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_boiler_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[bc.BoilerControl.Boiler_i_bcproc_boiler_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_In_Mode" ~> preContainer.In_Mode.string
        updates = updates + s"${bridge_id}_In_In_ValveOpen" ~> preContainer.In_ValveOpen.string
        if (preContainer.api_opMode.nonEmpty) {
          updates = updates + s"${bridge_id}_In_opMode" ~> preContainer.api_opMode.get.string
        }
        if (preContainer.api_programReady.nonEmpty) {
          updates = updates + s"${bridge_id}_In_programReady" ~> preContainer.api_programReady.get.string
        }
        if (preContainer.api_valve.nonEmpty) {
          updates = updates + s"${bridge_id}_In_valve" ~> preContainer.api_valve.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl0_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl0_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_In_isPumpOpen" ~> preContainer.In_isPumpOpen.string
        updates = updates + s"${bridge_id}_In_In_isPumpFlow" ~> preContainer.In_isPumpFlow.string
        updates = updates + s"${bridge_id}_In_In_pumpNumber" ~> preContainer.In_pumpNumber.string
        if (preContainer.api_opMode.nonEmpty) {
          updates = updates + s"${bridge_id}_In_opMode" ~> preContainer.api_opMode.get.string
        }
        if (preContainer.api_openPump.nonEmpty) {
          updates = updates + s"${bridge_id}_In_openPump" ~> preContainer.api_openPump.get.string
        }
        if (preContainer.api_programReady.nonEmpty) {
          updates = updates + s"${bridge_id}_In_programReady" ~> preContainer.api_programReady.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl1_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl1_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_In_isPumpOpen" ~> preContainer.In_isPumpOpen.string
        updates = updates + s"${bridge_id}_In_In_isPumpFlow" ~> preContainer.In_isPumpFlow.string
        updates = updates + s"${bridge_id}_In_In_pumpNumber" ~> preContainer.In_pumpNumber.string
        if (preContainer.api_opMode.nonEmpty) {
          updates = updates + s"${bridge_id}_In_opMode" ~> preContainer.api_opMode.get.string
        }
        if (preContainer.api_openPump.nonEmpty) {
          updates = updates + s"${bridge_id}_In_openPump" ~> preContainer.api_openPump.get.string
        }
        if (preContainer.api_programReady.nonEmpty) {
          updates = updates + s"${bridge_id}_In_programReady" ~> preContainer.api_programReady.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl2_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl2_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_In_isPumpOpen" ~> preContainer.In_isPumpOpen.string
        updates = updates + s"${bridge_id}_In_In_isPumpFlow" ~> preContainer.In_isPumpFlow.string
        updates = updates + s"${bridge_id}_In_In_pumpNumber" ~> preContainer.In_pumpNumber.string
        if (preContainer.api_opMode.nonEmpty) {
          updates = updates + s"${bridge_id}_In_opMode" ~> preContainer.api_opMode.get.string
        }
        if (preContainer.api_openPump.nonEmpty) {
          updates = updates + s"${bridge_id}_In_openPump" ~> preContainer.api_openPump.get.string
        }
        if (preContainer.api_programReady.nonEmpty) {
          updates = updates + s"${bridge_id}_In_programReady" ~> preContainer.api_programReady.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl3_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl3_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_In_isPumpOpen" ~> preContainer.In_isPumpOpen.string
        updates = updates + s"${bridge_id}_In_In_isPumpFlow" ~> preContainer.In_isPumpFlow.string
        updates = updates + s"${bridge_id}_In_In_pumpNumber" ~> preContainer.In_pumpNumber.string
        if (preContainer.api_opMode.nonEmpty) {
          updates = updates + s"${bridge_id}_In_opMode" ~> preContainer.api_opMode.get.string
        }
        if (preContainer.api_openPump.nonEmpty) {
          updates = updates + s"${bridge_id}_In_openPump" ~> preContainer.api_openPump.get.string
        }
        if (preContainer.api_programReady.nonEmpty) {
          updates = updates + s"${bridge_id}_In_programReady" ~> preContainer.api_programReady.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_waterMeter_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[bc.BoilerControl.WaterMeter_i_bcproc_waterMeter_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_In_volume" ~> preContainer.In_volume.string
        if (preContainer.api_opMode.nonEmpty) {
          updates = updates + s"${bridge_id}_In_opMode" ~> preContainer.api_opMode.get.string
        }
        if (preContainer.api_programReady.nonEmpty) {
          updates = updates + s"${bridge_id}_In_programReady" ~> preContainer.api_programReady.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_steamMeter_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[bc.BoilerControl.SteamMeter_i_bcproc_steamMeter_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_In_computedRate" ~> preContainer.In_computedRate.string
        updates = updates + s"${bridge_id}_In_In_volume" ~> preContainer.In_volume.string
        if (preContainer.api_opMode.nonEmpty) {
          updates = updates + s"${bridge_id}_In_opMode" ~> preContainer.api_opMode.get.string
        }
        if (preContainer.api_programReady.nonEmpty) {
          updates = updates + s"${bridge_id}_In_programReady" ~> preContainer.api_programReady.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_desk_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[bc.BoilerControl.OperatorDesk_i_bcproc_desk_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_In_isPumpBroken0" ~> preContainer.In_isPumpBroken0.string
        updates = updates + s"${bridge_id}_In_In_isPumpBroken1" ~> preContainer.In_isPumpBroken1.string
        updates = updates + s"${bridge_id}_In_In_isPumpBroken2" ~> preContainer.In_isPumpBroken2.string
        updates = updates + s"${bridge_id}_In_In_isPumpBroken3" ~> preContainer.In_isPumpBroken3.string
        updates = updates + s"${bridge_id}_In_In_isPumpControlBroken0" ~> preContainer.In_isPumpControlBroken0.string
        updates = updates + s"${bridge_id}_In_In_isPumpControlBroken1" ~> preContainer.In_isPumpControlBroken1.string
        updates = updates + s"${bridge_id}_In_In_isPumpControlBroken2" ~> preContainer.In_isPumpControlBroken2.string
        updates = updates + s"${bridge_id}_In_In_isPumpControlBroken3" ~> preContainer.In_isPumpControlBroken3.string
        updates = updates + s"${bridge_id}_In_In_isLevelBroken" ~> preContainer.In_isLevelBroken.string
        updates = updates + s"${bridge_id}_In_In_isSteamBroken" ~> preContainer.In_isSteamBroken.string
        if (preContainer.api_opMode.nonEmpty) {
          updates = updates + s"${bridge_id}_In_opMode" ~> preContainer.api_opMode.get.string
        }
        if (preContainer.api_pumpFail0.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpFail0" ~> preContainer.api_pumpFail0.get.string
        }
        if (preContainer.api_pumpFail1.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpFail1" ~> preContainer.api_pumpFail1.get.string
        }
        if (preContainer.api_pumpFail2.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpFail2" ~> preContainer.api_pumpFail2.get.string
        }
        if (preContainer.api_pumpFail3.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpFail3" ~> preContainer.api_pumpFail3.get.string
        }
        if (preContainer.api_pumpControlFail0.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlFail0" ~> preContainer.api_pumpControlFail0.get.string
        }
        if (preContainer.api_pumpControlFail1.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlFail1" ~> preContainer.api_pumpControlFail1.get.string
        }
        if (preContainer.api_pumpControlFail2.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlFail2" ~> preContainer.api_pumpControlFail2.get.string
        }
        if (preContainer.api_pumpControlFail3.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlFail3" ~> preContainer.api_pumpControlFail3.get.string
        }
        if (preContainer.api_levelFail.nonEmpty) {
          updates = updates + s"${bridge_id}_In_levelFail" ~> preContainer.api_levelFail.get.string
        }
        if (preContainer.api_steamFail.nonEmpty) {
          updates = updates + s"${bridge_id}_In_steamFail" ~> preContainer.api_steamFail.get.string
        }
        if (preContainer.api_pumpRepairAck0.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpRepairAck0" ~> preContainer.api_pumpRepairAck0.get.string
        }
        if (preContainer.api_pumpRepairAck1.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpRepairAck1" ~> preContainer.api_pumpRepairAck1.get.string
        }
        if (preContainer.api_pumpRepairAck2.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpRepairAck2" ~> preContainer.api_pumpRepairAck2.get.string
        }
        if (preContainer.api_pumpRepairAck3.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpRepairAck3" ~> preContainer.api_pumpRepairAck3.get.string
        }
        if (preContainer.api_pumpControlRepairAck0.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlRepairAck0" ~> preContainer.api_pumpControlRepairAck0.get.string
        }
        if (preContainer.api_pumpControlRepairAck1.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlRepairAck1" ~> preContainer.api_pumpControlRepairAck1.get.string
        }
        if (preContainer.api_pumpControlRepairAck2.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlRepairAck2" ~> preContainer.api_pumpControlRepairAck2.get.string
        }
        if (preContainer.api_pumpControlRepairAck3.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlRepairAck3" ~> preContainer.api_pumpControlRepairAck3.get.string
        }
        if (preContainer.api_levelRepairAck.nonEmpty) {
          updates = updates + s"${bridge_id}_In_levelRepairAck" ~> preContainer.api_levelRepairAck.get.string
        }
        if (preContainer.api_steamRepairAck.nonEmpty) {
          updates = updates + s"${bridge_id}_In_steamRepairAck" ~> preContainer.api_steamRepairAck.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_control_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[bc.BoilerControl.BoilerControl_i_bcproc_control_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_In_mode" ~> preContainer.In_mode.string
        updates = updates + s"${bridge_id}_In_In_C" ~> preContainer.In_C.string
        updates = updates + s"${bridge_id}_In_In_M1" ~> preContainer.In_M1.string
        updates = updates + s"${bridge_id}_In_In_M2" ~> preContainer.In_M2.string
        updates = updates + s"${bridge_id}_In_In_N1" ~> preContainer.In_N1.string
        updates = updates + s"${bridge_id}_In_In_N2" ~> preContainer.In_N2.string
        updates = updates + s"${bridge_id}_In_In_W" ~> preContainer.In_W.string
        updates = updates + s"${bridge_id}_In_In_U1" ~> preContainer.In_U1.string
        updates = updates + s"${bridge_id}_In_In_U2" ~> preContainer.In_U2.string
        updates = updates + s"${bridge_id}_In_In_q" ~> preContainer.In_q.string
        updates = updates + s"${bridge_id}_In_In_P" ~> preContainer.In_P.string
        updates = updates + s"${bridge_id}_In_In_v_steamRate" ~> preContainer.In_v_steamRate.string
        updates = updates + s"${bridge_id}_In_In_hasBoilerSentWaiting" ~> preContainer.In_hasBoilerSentWaiting.string
        updates = updates + s"${bridge_id}_In_In_isPump0Failing" ~> preContainer.In_isPump0Failing.string
        updates = updates + s"${bridge_id}_In_In_isPump1Failing" ~> preContainer.In_isPump1Failing.string
        updates = updates + s"${bridge_id}_In_In_isPump2Failing" ~> preContainer.In_isPump2Failing.string
        updates = updates + s"${bridge_id}_In_In_isPump3Failing" ~> preContainer.In_isPump3Failing.string
        updates = updates + s"${bridge_id}_In_In_isWaterMeterFailing" ~> preContainer.In_isWaterMeterFailing.string
        updates = updates + s"${bridge_id}_In_In_isSteamMeterFailing" ~> preContainer.In_isSteamMeterFailing.string
        updates = updates + s"${bridge_id}_In_In_p0" ~> preContainer.In_p0.string
        updates = updates + s"${bridge_id}_In_In_p1" ~> preContainer.In_p1.string
        updates = updates + s"${bridge_id}_In_In_p2" ~> preContainer.In_p2.string
        updates = updates + s"${bridge_id}_In_In_p3" ~> preContainer.In_p3.string
        updates = updates + s"${bridge_id}_In_In_qc1" ~> preContainer.In_qc1.string
        updates = updates + s"${bridge_id}_In_In_qc2" ~> preContainer.In_qc2.string
        updates = updates + s"${bridge_id}_In_In_qa1" ~> preContainer.In_qa1.string
        updates = updates + s"${bridge_id}_In_In_qa2" ~> preContainer.In_qa2.string
        updates = updates + s"${bridge_id}_In_In_shouldUpdatePumps" ~> preContainer.In_shouldUpdatePumps.string
        updates = updates + s"${bridge_id}_In_In_transmissionFailure" ~> preContainer.In_transmissionFailure.string
        if (preContainer.api_pumpOpen0.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpOpen0" ~> preContainer.api_pumpOpen0.get.string
        }
        if (preContainer.api_pumpOpen1.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpOpen1" ~> preContainer.api_pumpOpen1.get.string
        }
        if (preContainer.api_pumpOpen2.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpOpen2" ~> preContainer.api_pumpOpen2.get.string
        }
        if (preContainer.api_pumpOpen3.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpOpen3" ~> preContainer.api_pumpOpen3.get.string
        }
        if (preContainer.api_pumpFlow0.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpFlow0" ~> preContainer.api_pumpFlow0.get.string
        }
        if (preContainer.api_pumpFlow1.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpFlow1" ~> preContainer.api_pumpFlow1.get.string
        }
        if (preContainer.api_pumpFlow2.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpFlow2" ~> preContainer.api_pumpFlow2.get.string
        }
        if (preContainer.api_pumpFlow3.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpFlow3" ~> preContainer.api_pumpFlow3.get.string
        }
        if (preContainer.api_waterLevel.nonEmpty) {
          updates = updates + s"${bridge_id}_In_waterLevel" ~> preContainer.api_waterLevel.get.string
        }
        if (preContainer.api_steamRate.nonEmpty) {
          updates = updates + s"${bridge_id}_In_steamRate" ~> preContainer.api_steamRate.get.string
        }
        if (preContainer.api_stop.nonEmpty) {
          updates = updates + s"${bridge_id}_In_stop" ~> preContainer.api_stop.get.string
        }
        if (preContainer.api_boilerWaiting.nonEmpty) {
          updates = updates + s"${bridge_id}_In_boilerWaiting" ~> preContainer.api_boilerWaiting.get.string
        }
        if (preContainer.api_boilerReady.nonEmpty) {
          updates = updates + s"${bridge_id}_In_boilerReady" ~> preContainer.api_boilerReady.get.string
        }
        if (preContainer.api_waterMeterReady.nonEmpty) {
          updates = updates + s"${bridge_id}_In_waterMeterReady" ~> preContainer.api_waterMeterReady.get.string
        }
        if (preContainer.api_pumpControlReady0.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlReady0" ~> preContainer.api_pumpControlReady0.get.string
        }
        if (preContainer.api_pumpControlReady1.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlReady1" ~> preContainer.api_pumpControlReady1.get.string
        }
        if (preContainer.api_pumpControlReady2.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlReady2" ~> preContainer.api_pumpControlReady2.get.string
        }
        if (preContainer.api_pumpControlReady3.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlReady3" ~> preContainer.api_pumpControlReady3.get.string
        }
        if (preContainer.api_steamMeterReady.nonEmpty) {
          updates = updates + s"${bridge_id}_In_steamMeterReady" ~> preContainer.api_steamMeterReady.get.string
        }
        if (preContainer.api_pumpRepair0.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpRepair0" ~> preContainer.api_pumpRepair0.get.string
        }
        if (preContainer.api_pumpRepair1.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpRepair1" ~> preContainer.api_pumpRepair1.get.string
        }
        if (preContainer.api_pumpRepair2.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpRepair2" ~> preContainer.api_pumpRepair2.get.string
        }
        if (preContainer.api_pumpRepair3.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpRepair3" ~> preContainer.api_pumpRepair3.get.string
        }
        if (preContainer.api_pumpControlRepair0.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlRepair0" ~> preContainer.api_pumpControlRepair0.get.string
        }
        if (preContainer.api_pumpControlRepair1.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlRepair1" ~> preContainer.api_pumpControlRepair1.get.string
        }
        if (preContainer.api_pumpControlRepair2.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlRepair2" ~> preContainer.api_pumpControlRepair2.get.string
        }
        if (preContainer.api_pumpControlRepair3.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlRepair3" ~> preContainer.api_pumpControlRepair3.get.string
        }
        if (preContainer.api_levelRepair.nonEmpty) {
          updates = updates + s"${bridge_id}_In_levelRepair" ~> preContainer.api_levelRepair.get.string
        }
        if (preContainer.api_steamRepair.nonEmpty) {
          updates = updates + s"${bridge_id}_In_steamRepair" ~> preContainer.api_steamRepair.get.string
        }
        if (preContainer.api_pumpFailAck0.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpFailAck0" ~> preContainer.api_pumpFailAck0.get.string
        }
        if (preContainer.api_pumpFailAck1.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpFailAck1" ~> preContainer.api_pumpFailAck1.get.string
        }
        if (preContainer.api_pumpFailAck2.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpFailAck2" ~> preContainer.api_pumpFailAck2.get.string
        }
        if (preContainer.api_pumpFailAck3.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpFailAck3" ~> preContainer.api_pumpFailAck3.get.string
        }
        if (preContainer.api_pumpControlFailAck0.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlFailAck0" ~> preContainer.api_pumpControlFailAck0.get.string
        }
        if (preContainer.api_pumpControlFailAck1.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlFailAck1" ~> preContainer.api_pumpControlFailAck1.get.string
        }
        if (preContainer.api_pumpControlFailAck2.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlFailAck2" ~> preContainer.api_pumpControlFailAck2.get.string
        }
        if (preContainer.api_pumpControlFailAck3.nonEmpty) {
          updates = updates + s"${bridge_id}_In_pumpControlFailAck3" ~> preContainer.api_pumpControlFailAck3.get.string
        }
        if (preContainer.api_levelFailAck.nonEmpty) {
          updates = updates + s"${bridge_id}_In_levelFailAck" ~> preContainer.api_levelFailAck.get.string
        }
        if (preContainer.api_steamFailAck.nonEmpty) {
          updates = updates + s"${bridge_id}_In_steamFailAck" ~> preContainer.api_steamFailAck.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_boiler_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.Boiler_i_bcproc_boiler_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_Mode" ~> postContainer.Mode.string
        updates = updates + s"${bridge_id}_Out_ValveOpen" ~> postContainer.ValveOpen.string
        if (postContainer.api_waiting.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_waiting" ~> postContainer.api_waiting.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl0_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl0_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_isPumpOpen" ~> postContainer.isPumpOpen.string
        updates = updates + s"${bridge_id}_Out_isPumpFlow" ~> postContainer.isPumpFlow.string
        updates = updates + s"${bridge_id}_Out_pumpNumber" ~> postContainer.pumpNumber.string
        if (postContainer.api_pumpOpen.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpOpen" ~> postContainer.api_pumpOpen.get.string
        }
        if (postContainer.api_pumpFlow.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFlow" ~> postContainer.api_pumpFlow.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl1_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl1_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_isPumpOpen" ~> postContainer.isPumpOpen.string
        updates = updates + s"${bridge_id}_Out_isPumpFlow" ~> postContainer.isPumpFlow.string
        updates = updates + s"${bridge_id}_Out_pumpNumber" ~> postContainer.pumpNumber.string
        if (postContainer.api_pumpOpen.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpOpen" ~> postContainer.api_pumpOpen.get.string
        }
        if (postContainer.api_pumpFlow.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFlow" ~> postContainer.api_pumpFlow.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl2_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl2_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_isPumpOpen" ~> postContainer.isPumpOpen.string
        updates = updates + s"${bridge_id}_Out_isPumpFlow" ~> postContainer.isPumpFlow.string
        updates = updates + s"${bridge_id}_Out_pumpNumber" ~> postContainer.pumpNumber.string
        if (postContainer.api_pumpOpen.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpOpen" ~> postContainer.api_pumpOpen.get.string
        }
        if (postContainer.api_pumpFlow.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFlow" ~> postContainer.api_pumpFlow.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_pumpControl3_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.PumpControl_i_bcproc_pumpControl3_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_isPumpOpen" ~> postContainer.isPumpOpen.string
        updates = updates + s"${bridge_id}_Out_isPumpFlow" ~> postContainer.isPumpFlow.string
        updates = updates + s"${bridge_id}_Out_pumpNumber" ~> postContainer.pumpNumber.string
        if (postContainer.api_pumpOpen.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpOpen" ~> postContainer.api_pumpOpen.get.string
        }
        if (postContainer.api_pumpFlow.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFlow" ~> postContainer.api_pumpFlow.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_waterMeter_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.WaterMeter_i_bcproc_waterMeter_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_volume" ~> postContainer.volume.string
        if (postContainer.api_level.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_level" ~> postContainer.api_level.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_steamMeter_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.SteamMeter_i_bcproc_steamMeter_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_computedRate" ~> postContainer.computedRate.string
        updates = updates + s"${bridge_id}_Out_volume" ~> postContainer.volume.string
        if (postContainer.api_rate.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_rate" ~> postContainer.api_rate.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_desk_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.OperatorDesk_i_bcproc_desk_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_isPumpBroken0" ~> postContainer.isPumpBroken0.string
        updates = updates + s"${bridge_id}_Out_isPumpBroken1" ~> postContainer.isPumpBroken1.string
        updates = updates + s"${bridge_id}_Out_isPumpBroken2" ~> postContainer.isPumpBroken2.string
        updates = updates + s"${bridge_id}_Out_isPumpBroken3" ~> postContainer.isPumpBroken3.string
        updates = updates + s"${bridge_id}_Out_isPumpControlBroken0" ~> postContainer.isPumpControlBroken0.string
        updates = updates + s"${bridge_id}_Out_isPumpControlBroken1" ~> postContainer.isPumpControlBroken1.string
        updates = updates + s"${bridge_id}_Out_isPumpControlBroken2" ~> postContainer.isPumpControlBroken2.string
        updates = updates + s"${bridge_id}_Out_isPumpControlBroken3" ~> postContainer.isPumpControlBroken3.string
        updates = updates + s"${bridge_id}_Out_isLevelBroken" ~> postContainer.isLevelBroken.string
        updates = updates + s"${bridge_id}_Out_isSteamBroken" ~> postContainer.isSteamBroken.string
        if (postContainer.api_stop.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_stop" ~> postContainer.api_stop.get.string
        }
        if (postContainer.api_pumpRepair0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepair0" ~> postContainer.api_pumpRepair0.get.string
        }
        if (postContainer.api_pumpRepair1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepair1" ~> postContainer.api_pumpRepair1.get.string
        }
        if (postContainer.api_pumpRepair2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepair2" ~> postContainer.api_pumpRepair2.get.string
        }
        if (postContainer.api_pumpRepair3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepair3" ~> postContainer.api_pumpRepair3.get.string
        }
        if (postContainer.api_pumpControlRepair0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepair0" ~> postContainer.api_pumpControlRepair0.get.string
        }
        if (postContainer.api_pumpControlRepair1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepair1" ~> postContainer.api_pumpControlRepair1.get.string
        }
        if (postContainer.api_pumpControlRepair2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepair2" ~> postContainer.api_pumpControlRepair2.get.string
        }
        if (postContainer.api_pumpControlRepair3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepair3" ~> postContainer.api_pumpControlRepair3.get.string
        }
        if (postContainer.api_levelRepair.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_levelRepair" ~> postContainer.api_levelRepair.get.string
        }
        if (postContainer.api_steamRepair.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_steamRepair" ~> postContainer.api_steamRepair.get.string
        }
        if (postContainer.api_pumpFailAck0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFailAck0" ~> postContainer.api_pumpFailAck0.get.string
        }
        if (postContainer.api_pumpFailAck1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFailAck1" ~> postContainer.api_pumpFailAck1.get.string
        }
        if (postContainer.api_pumpFailAck2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFailAck2" ~> postContainer.api_pumpFailAck2.get.string
        }
        if (postContainer.api_pumpFailAck3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFailAck3" ~> postContainer.api_pumpFailAck3.get.string
        }
        if (postContainer.api_pumpControlFailAck0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFailAck0" ~> postContainer.api_pumpControlFailAck0.get.string
        }
        if (postContainer.api_pumpControlFailAck1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFailAck1" ~> postContainer.api_pumpControlFailAck1.get.string
        }
        if (postContainer.api_pumpControlFailAck2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFailAck2" ~> postContainer.api_pumpControlFailAck2.get.string
        }
        if (postContainer.api_pumpControlFailAck3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFailAck3" ~> postContainer.api_pumpControlFailAck3.get.string
        }
        if (postContainer.api_levelFailAck.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_levelFailAck" ~> postContainer.api_levelFailAck.get.string
        }
        if (postContainer.api_steamFailAck.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_steamFailAck" ~> postContainer.api_steamFailAck.get.string
        }
        return updates
      case bc.runtimemonitor.ObservationKind.BoilerControlSystem_i_Instance_bcproc_control_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bc.BoilerControl.BoilerControl_i_bcproc_control_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_mode" ~> postContainer.mode.string
        updates = updates + s"${bridge_id}_Out_C" ~> postContainer.C.string
        updates = updates + s"${bridge_id}_Out_M1" ~> postContainer.M1.string
        updates = updates + s"${bridge_id}_Out_M2" ~> postContainer.M2.string
        updates = updates + s"${bridge_id}_Out_N1" ~> postContainer.N1.string
        updates = updates + s"${bridge_id}_Out_N2" ~> postContainer.N2.string
        updates = updates + s"${bridge_id}_Out_W" ~> postContainer.W.string
        updates = updates + s"${bridge_id}_Out_U1" ~> postContainer.U1.string
        updates = updates + s"${bridge_id}_Out_U2" ~> postContainer.U2.string
        updates = updates + s"${bridge_id}_Out_q" ~> postContainer.q.string
        updates = updates + s"${bridge_id}_Out_P" ~> postContainer.P.string
        updates = updates + s"${bridge_id}_Out_v_steamRate" ~> postContainer.v_steamRate.string
        updates = updates + s"${bridge_id}_Out_hasBoilerSentWaiting" ~> postContainer.hasBoilerSentWaiting.string
        updates = updates + s"${bridge_id}_Out_isPump0Failing" ~> postContainer.isPump0Failing.string
        updates = updates + s"${bridge_id}_Out_isPump1Failing" ~> postContainer.isPump1Failing.string
        updates = updates + s"${bridge_id}_Out_isPump2Failing" ~> postContainer.isPump2Failing.string
        updates = updates + s"${bridge_id}_Out_isPump3Failing" ~> postContainer.isPump3Failing.string
        updates = updates + s"${bridge_id}_Out_isWaterMeterFailing" ~> postContainer.isWaterMeterFailing.string
        updates = updates + s"${bridge_id}_Out_isSteamMeterFailing" ~> postContainer.isSteamMeterFailing.string
        updates = updates + s"${bridge_id}_Out_p0" ~> postContainer.p0.string
        updates = updates + s"${bridge_id}_Out_p1" ~> postContainer.p1.string
        updates = updates + s"${bridge_id}_Out_p2" ~> postContainer.p2.string
        updates = updates + s"${bridge_id}_Out_p3" ~> postContainer.p3.string
        updates = updates + s"${bridge_id}_Out_qc1" ~> postContainer.qc1.string
        updates = updates + s"${bridge_id}_Out_qc2" ~> postContainer.qc2.string
        updates = updates + s"${bridge_id}_Out_qa1" ~> postContainer.qa1.string
        updates = updates + s"${bridge_id}_Out_qa2" ~> postContainer.qa2.string
        updates = updates + s"${bridge_id}_Out_shouldUpdatePumps" ~> postContainer.shouldUpdatePumps.string
        updates = updates + s"${bridge_id}_Out_transmissionFailure" ~> postContainer.transmissionFailure.string
        if (postContainer.api_opMode.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_opMode" ~> postContainer.api_opMode.get.string
        }
        if (postContainer.api_openPump0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_openPump0" ~> postContainer.api_openPump0.get.string
        }
        if (postContainer.api_openPump1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_openPump1" ~> postContainer.api_openPump1.get.string
        }
        if (postContainer.api_openPump2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_openPump2" ~> postContainer.api_openPump2.get.string
        }
        if (postContainer.api_openPump3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_openPump3" ~> postContainer.api_openPump3.get.string
        }
        if (postContainer.api_ready.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_ready" ~> postContainer.api_ready.get.string
        }
        if (postContainer.api_valve.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_valve" ~> postContainer.api_valve.get.string
        }
        if (postContainer.api_pumpFail0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFail0" ~> postContainer.api_pumpFail0.get.string
        }
        if (postContainer.api_pumpFail1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFail1" ~> postContainer.api_pumpFail1.get.string
        }
        if (postContainer.api_pumpFail2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFail2" ~> postContainer.api_pumpFail2.get.string
        }
        if (postContainer.api_pumpFail3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpFail3" ~> postContainer.api_pumpFail3.get.string
        }
        if (postContainer.api_pumpControlFail0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFail0" ~> postContainer.api_pumpControlFail0.get.string
        }
        if (postContainer.api_pumpControlFail1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFail1" ~> postContainer.api_pumpControlFail1.get.string
        }
        if (postContainer.api_pumpControlFail2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFail2" ~> postContainer.api_pumpControlFail2.get.string
        }
        if (postContainer.api_pumpControlFail3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlFail3" ~> postContainer.api_pumpControlFail3.get.string
        }
        if (postContainer.api_levelFail.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_levelFail" ~> postContainer.api_levelFail.get.string
        }
        if (postContainer.api_steamFail.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_steamFail" ~> postContainer.api_steamFail.get.string
        }
        if (postContainer.api_pumpRepairAck0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepairAck0" ~> postContainer.api_pumpRepairAck0.get.string
        }
        if (postContainer.api_pumpRepairAck1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepairAck1" ~> postContainer.api_pumpRepairAck1.get.string
        }
        if (postContainer.api_pumpRepairAck2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepairAck2" ~> postContainer.api_pumpRepairAck2.get.string
        }
        if (postContainer.api_pumpRepairAck3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpRepairAck3" ~> postContainer.api_pumpRepairAck3.get.string
        }
        if (postContainer.api_pumpControlRepairAck0.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepairAck0" ~> postContainer.api_pumpControlRepairAck0.get.string
        }
        if (postContainer.api_pumpControlRepairAck1.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepairAck1" ~> postContainer.api_pumpControlRepairAck1.get.string
        }
        if (postContainer.api_pumpControlRepairAck2.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepairAck2" ~> postContainer.api_pumpControlRepairAck2.get.string
        }
        if (postContainer.api_pumpControlRepairAck3.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_pumpControlRepairAck3" ~> postContainer.api_pumpControlRepairAck3.get.string
        }
        if (postContainer.api_levelRepairAck.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_levelRepairAck" ~> postContainer.api_levelRepairAck.get.string
        }
        if (postContainer.api_steamRepairAck.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_steamRepairAck" ~> postContainer.api_steamRepairAck.get.string
        }
        return updates
      case _ => return Map.empty
    }
  }
}