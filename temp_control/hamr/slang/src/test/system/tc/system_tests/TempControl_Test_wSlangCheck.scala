package tc.system_tests

import art.Art
import art.scheduling.static._
import org.sireum._
import tc._
import tc.system_tests.TempControl_Inputs_Container_SlangCheck.{NameProvider, TestRow}
// alias nicknames
import tc.TempSensor.{TempSensorPeriodic_p_tcproc_tempSensor_SystemTestAPI => TempSensor}
import tc.CoolingFan.{FanPeriodic_p_tcproc_fan_SystemTestAPI => Fan}
import tc.TempControlSoftwareSystem.{TempControlPeriodic_p_tcproc_tempControl_SystemTestAPI => TempControl}
import tc.TempControlSoftwareSystem.{OperatorInterfacePeriodic_p_tcproc_operatorInterface_SystemTestAPI => OperatorInterface}


// Do not edit this file as it will be overwritten if SystemTestArtifactGen is rerun

class TempControl_Test_wSlangCheck
  extends TempControl_Inputs_Container_SlangCheck {

  //===========================================================
  //  S c h e d u l a r     and    S t e p p e r     Configuration
  //===========================================================

  // note: this is overriding SystemTestSuite's 'def scheduler: Scheduler'
  //       abstract method
  //var scheduler: StaticScheduler = Schedulers.getStaticSchedulerH(MNone())
  var scheduler: StaticScheduler = Schedulers.getStaticScheduler(
    StaticSchedulerCust.staticSchedule,
    StaticSchedulerCust.domainToBridgeIdMap,
    StaticSchedulerCust.threadNickNames,
    ISZCommandProvider(ISZ()))

  def compute(isz: ISZ[Command]): Unit = {
    scheduler = scheduler(commandProvider = ISZCommandProvider(isz :+ Stop()))

    Art.computePhase(scheduler)
  }

  override def beforeEach(): Unit = {

    // uncomment the following to disable the various guis and to suppress the log streams
    disableLogsAndGuis()

    super.beforeEach()
  }

  //===========================================================
  //  S l a n g   C h e c k    Infrastructure
  //===========================================================

  val maxTests = 100
  var verbose: B = T

  val testMatrix: Map[String, TestRow] = Map.empty ++ ISZ(
    "FanOn" ~> TestRow(
      testDescription = "FanOn",
      testMethod = NameProvider("1HP", (tc_1HP_script_schema _).asInstanceOf[(Any, Any) => B]),
      profile =getDefaultProfile,
      preStateCheck = (examplePreStateContainerFilter _).asInstanceOf[Any => B],
      property = NameProvider("FanOn", (sysProp_fanOn _).asInstanceOf[(Any, Any) => B])
    ),
  "FanOff" ~> TestRow(
    testDescription = "FanOff",
    testMethod = NameProvider("1HP", (tc_1HP_script_schema _).asInstanceOf[(Any, Any) => B]),
    profile = getDefaultProfile,
    preStateCheck = (examplePreStateContainerFilter _).asInstanceOf[Any => B],
    property = NameProvider("FanOff", (sysProp_fanOff _).asInstanceOf[(Any, Any) => B])
  )
  )

  for (testRow <- testMatrix.entries) {
    run(testRow._1, testRow._2)
  }

  def genTestName(testFamilyName: String, testRow: TestRow): String = {
    return s"${testFamilyName}: ${testRow.testMethod.name}: ${testRow.property.name}: ${testRow.profile.name}"
  }

  def genTestNameJson(testFamilyName: String, testRow: TestRow): String = {
    @strictpure def p(str: String): ST = Json.Printer.printString(str)
    return st"""{"testFamilyName" : ${p(testFamilyName)}, "testDescription" : ${p(testRow.testDescription)}, "testMethodName": ${p(testRow.testMethod.name)}, "property" : ${p(testRow.property.name)}, "profile" : ${p(testRow.profile.name)}}"""".render
  }

  def run(testFamilyName: String, testRow: TestRow): Unit = {

    for (i <- 0 until maxTests) {
      val testName = s"${genTestName(testFamilyName, testRow)}_$i"
      this.registerTest(testName) {
        var retry: B = T
        var j: Z = 0

        while (j < testRow.profile.numTestVectorGenRetries && retry) {
          if (verbose && j > 0) {
            println(s"Retry $j:")
          }

          next(testRow.profile) match {
            case Some(container) =>
              if (!testRow.preStateCheck(container)) {
                // retry
              } else {
                assert(testRow.testMethod.function(container, testRow.property.function))
                retry = F
              }
            case _ =>
          }
          j = j + 1
        }
      }
    }
  }

  // a pre-state container filter could prove useful/necessary in order to
  // ensure that the values in the container will satisfy the assume/requires clause
  // of a component in the system that will receive those values
  def examplePreStateContainerFilter(container: TempControl_Inputs_Container): B = {
    // e.g. return container.low < container.high
    return T
  }

  //=============================================================
  //  Profiles
  //=============================================================

  // ToDo


  //============================================================
  //  Test Script S c h e m a s
  //============================================================
  def tc_1HP_script_schema(inject_container: TempControl_Inputs_Container,
                           prop: (TempControl_Inputs_Container, TempControl_Outputs_Container) =>
                                    B
                                 ): B = {

    // -------------------- trace prefix --------------------

    // ====== Initialization =====
    // run the system's initialization phase
    //  ... automatically generated basic on indication that this script is a "compute phase test script"

    Art.initializePhase(scheduler)

    // ====== Compute ======

    //  ----  r u n   t o   a r b i t r a r y    s y s t e m    s t a t e

    // Abstractly, run the system an arbitrary number of steps

    compute(ISZ(Hstep(2)))

    compute(ISZ(RunToThread("TempControl")))

    // -------------------- inject / observe inputs --------------------
    //   ...eventually, auto-generated from higher-level specification of
    //      injection and observation vectors, along with temporal point
    //      declarations of when to inject and observe
    // -------------------------------------------------------------------

    // inject values
    TempControl.put_currentTemp(inject_container.currentTemp)
    TempControl.put_setPoint(inject_container.setPoint)
    TempControlSoftwareSystem.TempControlPeriodic_p_tcproc_tempControl.latestFanCmd
      = inject_container.latestFanCmd

    // ---------------- trace steps ----------------------

    // run to end of current hyper-period - and check outputs of selected components
    compute(ISZ(Hstep(1)))

    // ------------------ observe output -- build output observation vector ------------------
    //   ...eventually, auto-generated from higher-level specification of
    //      injection and observation vectors, along with temporal point
    //      declarations of when to inject and observe
    // ---------------------------------------------------------------------------------------

    val api_fan_cmd = TempControl.get_api_fanCmd()
    val outputs_container = TempControl_Outputs_Container(
      fanCmd = api_fan_cmd)

    // gracefully take system down
    Art.finalizePhase(scheduler)

    // ------------------ check property of collected observations ------------------
    //   ...eventually, auto-generated from higher-level specification of
    //      property evaluation
    // ---------------------------------------------------------------------------------------

    return prop(inject_container, outputs_container)
  }

  //===========================================================
  //  P r o p e r t i e s
  //===========================================================

  def sysProp_fanOn(inputs_container: TempControl_Inputs_Container,
                    outputs_container: TempControl_Outputs_Container): B = {
    val trigger_condition = (inputs_container.currentTemp.degrees > inputs_container.setPoint.high.degrees)
    val desired_condition = outputs_container.fanCmd == CoolingFan.FanCmd.On
    return (trigger_condition.->:(desired_condition))
  }

  def sysProp_fanOff(inputs_container: TempControl_Inputs_Container,
                    outputs_container: TempControl_Outputs_Container): B = {
    val trigger_condition = (inputs_container.currentTemp.degrees < inputs_container.setPoint.low.degrees)
    val desired_condition = outputs_container.fanCmd == CoolingFan.FanCmd.Off
    return (trigger_condition.->:(desired_condition))
  }

}